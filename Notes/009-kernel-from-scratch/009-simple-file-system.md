# ä»é›¶å†™ OS å†…æ ¸-ç¬¬ä¹ç¯‡ï¼šç”¨æˆ·æ€ç¨‹åºåŠ è½½ â€”â€” ELF è§£æä¸ç®€æ˜“æ–‡ä»¶ç³»ç»Ÿ

> **â€œä½ çš„ OS èƒ½ fork/execï¼Œä½†ç¨‹åºä»å“ªæ¥ï¼Ÿ  
> ä»Šå¤©ï¼Œæˆ‘ä»¬æ„å»ºç¬¬ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œè®©å†…æ ¸èƒ½ä»â€˜ç£ç›˜â€™åŠ è½½ç”¨æˆ·ç¨‹åºï¼â€**

åœ¨ä¸Šä¸€ç¯‡ä¸­ï¼Œæˆ‘ä»¬å®ç°äº† `fork` å’Œ `exec`ï¼Œä½†ç”¨æˆ·ç¨‹åºä»éœ€**ç¡¬ç¼–ç åœ¨å†…æ ¸é•œåƒä¸­**ã€‚  
è¿™æ˜¾ç„¶ä¸ç°å®â€”â€”çœŸæ­£çš„æ“ä½œç³»ç»Ÿå¿…é¡»èƒ½**ä»å­˜å‚¨è®¾å¤‡åŠ è½½ä»»æ„ç¨‹åº**ã€‚

è€Œè¿™ä¸€åˆ‡ï¼Œä¾èµ–ä¸¤å¤§æ ¸å¿ƒæ¨¡å—ï¼š
âœ… **æ–‡ä»¶ç³»ç»Ÿ** â€”â€” ç»„ç»‡å’Œç®¡ç†ç£ç›˜ä¸Šçš„æ–‡ä»¶  
âœ… **ELF åŠ è½½å™¨** â€”â€” è§£æå¹¶åŠ è½½å¯æ‰§è¡Œæ–‡ä»¶åˆ°å†…å­˜  

ä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥å®ç°ä¸€ä¸ª**æç®€ä½†å¯ç”¨çš„æ–‡ä»¶ç³»ç»Ÿï¼ˆInitramfs é£æ ¼ï¼‰**ï¼Œå¹¶å®Œæˆ **ELF ç¨‹åºåŠ è½½**ï¼Œè®©ä½ çš„ `exec("/bin/ls")` çœŸæ­£å·¥ä½œï¼

---

## ğŸ—‚ï¸ ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦æ–‡ä»¶ç³»ç»Ÿï¼Ÿ

æ²¡æœ‰æ–‡ä»¶ç³»ç»Ÿï¼Œä½ çš„ OS å°±åƒä¸€å°æ²¡æœ‰ç¡¬ç›˜çš„ç”µè„‘â€”â€”  
æ‰€æœ‰ç¨‹åºå¿…é¡»ç¼–è¯‘è¿›å†…æ ¸ï¼Œæ— æ³•åŠ¨æ€æ‰©å±•ã€‚

### æ–‡ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒèŒè´£ï¼š
- **å‘½å**ï¼šé€šè¿‡è·¯å¾„ï¼ˆå¦‚ `/bin/ls`ï¼‰è®¿é—®æ–‡ä»¶
- **å­˜å‚¨**ï¼šå°†æ–‡ä»¶å†…å®¹æ˜ å°„åˆ°ç‰©ç†å­˜å‚¨ï¼ˆç£ç›˜/å†…å­˜ï¼‰
- **å…ƒæ•°æ®**ï¼šè®°å½•æ–‡ä»¶å¤§å°ã€æƒé™ã€ç±»å‹ç­‰

> ğŸ’¡ **åˆæœŸæ— éœ€å¤æ‚ç£ç›˜é©±åŠ¨**â€”â€”æˆ‘ä»¬å¯ä»¥ç”¨ **Initramfsï¼ˆåˆå§‹å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼‰**ï¼š  
> å°†æ‰€æœ‰æ–‡ä»¶æ‰“åŒ…è¿›å†…æ ¸é•œåƒï¼Œå¯åŠ¨æ—¶åŠ è½½åˆ°å†…å­˜ã€‚

---

## ğŸ“¦ äºŒã€Initramfsï¼šæœ€ç®€æ–‡ä»¶ç³»ç»Ÿå®ç°

**Initramfs** æ˜¯ Linux å¯åŠ¨åˆæœŸå¸¸ç”¨çš„å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼Œéå¸¸é€‚åˆæˆ‘ä»¬çš„åœºæ™¯ã€‚

### è®¾è®¡æ€è·¯ï¼š
1. **å°†æ‰€æœ‰ç”¨æˆ·ç¨‹åºæ‰“åŒ…æˆä¸€ä¸ªäºŒè¿›åˆ¶ blob**
2. **å®šä¹‰ç®€å•ç›®å½•ç»“æ„**ï¼ˆæ‰å¹³æˆ–æ ‘å½¢ï¼‰
3. **å†…æ ¸å¯åŠ¨æ—¶è§£æ blobï¼Œæ„å»ºå†…å­˜ä¸­çš„æ–‡ä»¶ç´¢å¼•**

### æ–‡ä»¶æ¡ç›®æ ¼å¼ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š
```c
struct initramfs_entry {
    char name[64];      // æ–‡ä»¶åï¼ˆå¦‚ "bin/ls"ï¼‰
    uint32_t offset;    // åœ¨ blob ä¸­çš„åç§»
    uint32_t size;      // æ–‡ä»¶å¤§å°
};
```

### æ„å»ºæµç¨‹ï¼ˆMakefileï¼‰ï¼š
```makefile
# å°†æ‰€æœ‰ç”¨æˆ·ç¨‹åºæ‰“åŒ…
user_files.bin: bin/ls bin/cat bin/sh
    echo "bin/ls" | xxd -r -p > $@
    wc -c bin/ls | awk '{printf "%08x", $$1}' | xxd -r -p >> $@
    cat bin/ls >> $@
    # ... é‡å¤å¤„ç†å…¶ä»–æ–‡ä»¶

# é“¾æ¥è¿›å†…æ ¸
kernel.bin: boot.o kernel.o user_files.bin
    $(LD) -T linker.ld -o $@ $^ --format=binary user_files.bin --format=default
```

> ğŸ“Œ **å…³é”®**ï¼šä½¿ç”¨ `--format=binary` å°† `user_files.bin` ä½œä¸ºäºŒè¿›åˆ¶æ•°æ®é“¾æ¥è¿›å†…æ ¸ã€‚

---

## ğŸ” ä¸‰ã€ELF æ–‡ä»¶æ ¼å¼é€Ÿè§ˆ

ELFï¼ˆExecutable and Linkable Formatï¼‰æ˜¯ Unix ç³»ç»Ÿçš„æ ‡å‡†å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ã€‚

### å…³é”®ç»“æ„ï¼š
| ç»“æ„ | ä½œç”¨ |
|------|------|
| **ELF Header** | æè¿°æ¶æ„ã€å…¥å£åœ°å€ã€ç¨‹åºå¤´åç§» |
| **Program Header Table** | æè¿°å¦‚ä½•åŠ è½½åˆ°å†…å­˜ï¼ˆ`PT_LOAD` æ®µï¼‰ |
| **Sections** | ç¼–è¯‘é“¾æ¥ç”¨ï¼ˆè¿è¡Œæ—¶ä¸éœ€è¦ï¼‰ |

### æˆ‘ä»¬å…³å¿ƒçš„å­—æ®µï¼ˆ32 ä½ï¼‰ï¼š
```c
// ELF å¤´
struct elf_header {
    uint8_t  e_ident[16];   // é­”æ•°: 0x7F "ELF"
    uint16_t e_type;        // ET_EXEC = å¯æ‰§è¡Œæ–‡ä»¶
    uint32_t e_entry;       // å…¥å£è™šæ‹Ÿåœ°å€
    uint32_t e_phoff;       // ç¨‹åºå¤´è¡¨åç§»
    uint16_t e_phnum;       // ç¨‹åºå¤´æ•°é‡
};

// ç¨‹åºå¤´
struct elf_program_header {
    uint32_t p_type;        // PT_LOAD = éœ€åŠ è½½
    uint32_t p_offset;      // æ–‡ä»¶å†…åç§»
    uint32_t p_vaddr;       // è™šæ‹Ÿåœ°å€
    uint32_t p_filesz;      // æ–‡ä»¶ä¸­å¤§å°
    uint32_t p_memsz;       // å†…å­˜ä¸­å¤§å°
    uint32_t p_flags;       // R/W/X æƒé™
};
```

> âœ… **åŠ è½½å™¨åªéœ€è§£æ Program Headersï¼Œå¿½ç•¥ Sectionsï¼**

---

## âš™ï¸ å››ã€å®ç° ELF åŠ è½½å™¨

### æ­¥éª¤ï¼š
1. **ä»æ–‡ä»¶ç³»ç»Ÿè¯»å– ELF æ–‡ä»¶åˆ°å†…æ ¸ç¼“å†²åŒº**
2. **éªŒè¯ ELF é­”æ•°å’Œç±»å‹**
3. **éå† Program Headersï¼ŒåŠ è½½ `PT_LOAD` æ®µ**
4. **è®¾ç½®å…¥å£åœ°å€**

### ä»£ç æ¡†æ¶ï¼š
```c
int load_elf_to_user(const char *path, uint32_t cr3_dir) {
    // 1. ä» Initramfs è¯»å–æ–‡ä»¶
    void *elf_data = initramfs_read_file(path);
    if (!elf_data) return -1;

    // 2. éªŒè¯ ELF å¤´
    elf_header *ehdr = (elf_header*)elf_data;
    if (ehdr->e_ident[0] != 0x7F || 
        memcmp(ehdr->e_ident + 1, "ELF", 3) != 0 ||
        ehdr->e_type != ET_EXEC) {
        return -1;
    }

    // 3. éå†ç¨‹åºå¤´
    elf_program_header *phdr = (elf_program_header*)((char*)elf_data + ehdr->e_phoff);
    for (int i = 0; i < ehdr->e_phnum; i++) {
        if (phdr[i].p_type == PT_LOAD) {
            // åˆ†é…ç”¨æˆ·ç‰©ç†é¡µ
            uint32_t vaddr = phdr[i].p_vaddr;
            uint32_t memsz = phdr[i].p_memsz;
            uint32_t filesz = phdr[i].p_filesz;

            // æ˜ å°„è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†é¡µ
            map_user_pages(cr3_dir, vaddr, memsz, 
                          (phdr[i].p_flags & PF_W) ? PAGE_RW : 0);

            // å¤åˆ¶æ–‡ä»¶å†…å®¹
            void *phys_addr = get_phys_addr(cr3_dir, vaddr);
            memcpy(phys_addr, (char*)elf_data + phdr[i].p_offset, filesz);

            // .bss éƒ¨åˆ†æ¸…é›¶
            if (memsz > filesz) {
                memset(phys_addr + filesz, 0, memsz - filesz);
            }
        }
    }

    current_task->user_eip = ehdr->e_entry;
    return 0;
}
```

> ğŸ”‘ **`map_user_pages`**ï¼šä¸ºç”¨æˆ·è™šæ‹Ÿåœ°å€åˆ†é…ç‰©ç†é¡µå¹¶æ›´æ–°é¡µè¡¨ã€‚

---

## ğŸ“ äº”ã€æ–‡ä»¶ç³»ç»Ÿ APIï¼šå†…æ ¸å¦‚ä½•â€œæ‰¾â€æ–‡ä»¶ï¼Ÿ

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç®€å•çš„ VFSï¼ˆè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼‰å±‚ï¼ŒåˆæœŸåªæ”¯æŒ Initramfsï¼š

```c
// æ–‡ä»¶æ“ä½œæŠ½è±¡
struct file_ops {
    int (*read)(void *buf, size_t count, off_t offset);
    // ... å…¶ä»–æ“ä½œï¼ˆwrite, open ç­‰æš‚ä¸å®ç°ï¼‰
};

// æ–‡ä»¶æè¿°ç¬¦
struct file {
    struct file_ops *f_ops;
    void *private_data; // æŒ‡å‘ initramfs_entry
    off_t f_pos;
};

// ç³»ç»Ÿè°ƒç”¨ï¼šopen
int sys_open(const char *pathname, int flags) {
    struct initramfs_entry *entry = initramfs_find(pathname);
    if (!entry) return -1;

    struct file *f = alloc_file();
    f->f_ops = &initramfs_ops;
    f->private_data = entry;
    return alloc_fd(f); // åˆ†é…æ–‡ä»¶æè¿°ç¬¦
}

// ç³»ç»Ÿè°ƒç”¨ï¼šread
int sys_read(int fd, void *buf, size_t count) {
    struct file *f = get_file(fd);
    return f->f_ops->read(f, buf, count, f->f_pos);
}
```

> ğŸ’¡ **`exec` å†…éƒ¨ä¼šè°ƒç”¨ `open` + `read` è¯»å– ELF æ–‡ä»¶**ï¼Œä¸ç”¨æˆ·ç¨‹åºå…±ç”¨åŒä¸€å¥— VFSï¼

---

## ğŸ§ª å…­ã€æµ‹è¯•ï¼šçœŸæ­£çš„ exec("/bin/ls")

**æ„å»ºç”¨æˆ·ç¨‹åº**ï¼š
```bash
# ç¼–è¯‘ ls
i686-elf-gcc -ffreestanding -nostdlib -o bin/ls ls.c -T user.ld

# æ‰“åŒ…è¿› Initramfs
./build_initramfs bin/ls bin/cat bin/sh > user_files.bin
```

**å†…æ ¸ä¸­**ï¼š
```c
void init_process() {
    // exec ä¼šè‡ªåŠ¨è°ƒç”¨ open("/bin/ls") + read
    exec("/bin/ls", (char*[]){"ls", NULL});
}
```

è¿è¡Œæ•ˆæœï¼š
```
bin/
cat
ls
sh
```

âœ… **æˆåŠŸä»â€œç£ç›˜â€ï¼ˆå†…å­˜ä¸­çš„ Initramfsï¼‰åŠ è½½å¹¶è¿è¡Œç”¨æˆ·ç¨‹åºï¼**

---

## âš ï¸ ä¸ƒã€å±€é™ä¸æœªæ¥æ–¹å‘

å½“å‰å®ç°ä»å¾ˆåˆçº§ï¼Œä½†ä¸ºåç»­æ‰“ä¸‹åŸºç¡€ï¼š

| é—®é¢˜ | æœªæ¥æ–¹æ¡ˆ |
|------|----------|
| **åªè¯» Initramfs** | å®ç° ext2/FAT32 ç£ç›˜æ–‡ä»¶ç³»ç»Ÿ |
| **æ— åŠ¨æ€é“¾æ¥** | å®ç° ELF åŠ¨æ€åŠ è½½å™¨ï¼ˆld.soï¼‰ |
| **æ— æ–‡ä»¶æƒé™** | æ·»åŠ  inode å’Œæƒé™ä½ |
| **æ— ç›®å½•éå†** | å®ç° `opendir`/`readdir` |

> ğŸŒ± **ä¸‹ä¸€æ­¥ï¼šå°† Initramfs æ›¿æ¢ä¸ºçœŸæ­£çš„ç£ç›˜æ–‡ä»¶ç³»ç»Ÿï¼ˆå¦‚ FAT32ï¼‰**ï¼Œæ”¯æŒä» SD å¡/ç¡¬ç›˜åŠ è½½ç¨‹åºï¼

---

## ğŸ’¬ å†™åœ¨æœ€å

æ–‡ä»¶ç³»ç»Ÿä¸ ELF åŠ è½½å™¨ï¼Œ  
æ˜¯è¿æ¥**é™æ€å†…æ ¸**ä¸**åŠ¨æ€ç”¨æˆ·ä¸–ç•Œ**çš„æ¡¥æ¢ã€‚

ä»Šå¤©ä½ æ„å»ºçš„è¿™ä¸ªç®€æ˜“ Initramfsï¼Œ  
æ­£æ˜¯ Linux å¯åŠ¨æ—¶ `initrd` çš„é›å½¢ã€‚

> ğŸŒŸ **ä»æ­¤ï¼Œä½ çš„æ“ä½œç³»ç»ŸçœŸæ­£â€œæ´»â€äº†èµ·æ¥â€”â€”å®ƒèƒ½ç”Ÿé•¿ï¼Œèƒ½è¿›åŒ–ï¼Œèƒ½è¿è¡Œä»»ä½•ä½ ç¼–è¯‘çš„ç¨‹åºã€‚**

---

ğŸ“¬ **åŠ¨æ‰‹æŒ‘æˆ˜**ï¼š  
æ·»åŠ ä¸€ä¸ªæ–°ç”¨æˆ·ç¨‹åºï¼ˆå¦‚ `echo`ï¼‰ï¼Œæ‰“åŒ…è¿› Initramfsï¼Œå¹¶é€šè¿‡ `exec` è¿è¡Œå®ƒã€‚  
æ¬¢è¿åœ¨è¯„è®ºåŒºåˆ†äº«ä½ çš„æ–‡ä»¶åˆ—è¡¨ï¼

ğŸ‘‡ ä¸‹ä¸€ç¯‡ä½ æƒ³çœ‹ï¼š**FAT32 æ–‡ä»¶ç³»ç»Ÿå®æˆ˜**ï¼Œè¿˜æ˜¯ **æ—¶é’Ÿä¸­æ–­ä¸æŠ¢å å¼è°ƒåº¦**ï¼Ÿ

---

**#æ“ä½œç³»ç»Ÿ #å†…æ ¸å¼€å‘ #æ–‡ä»¶ç³»ç»Ÿ #ELF #Initramfs #ç”¨æˆ·ç¨‹åºåŠ è½½ #ä»é›¶å¼€å§‹**

---

> ğŸ“¢ **å½©è›‹**ï¼šå…³æ³¨åå›å¤å…³é”®è¯ **â€œelfâ€**ï¼Œè·å–ï¼š
> - å®Œæ•´ ELF åŠ è½½å™¨ä»£ç 
> - Initramfs æ„å»ºè„šæœ¬ï¼ˆPythonï¼‰
> - ç”¨æˆ·ç¨‹åºé“¾æ¥è„šæœ¬ï¼ˆuser.ldï¼‰
