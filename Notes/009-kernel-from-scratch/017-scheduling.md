
# ä»Žé›¶å†™ OS å†…æ ¸-ç¬¬åä¸ƒç¯‡ï¼šè°ƒåº¦å™¨ â€”â€” è®©å¤šä»»åŠ¡çœŸæ­£â€œå¹¶å‘â€èµ·æ¥ï¼

> **â€œåä½œå¼å¤šä»»åŠ¡ä¾èµ–ç¨‹åºä¸»åŠ¨è®©å‡º CPUï¼Œä¸€æ—¦æ­»å¾ªçŽ¯ï¼Œç³»ç»Ÿå°±å¡æ­»ã€‚  
> ä»Šå¤©ï¼Œæˆ‘ä»¬å¼•å…¥æ—¶é’Ÿä¸­æ–­ï¼Œå®žçŽ°æŠ¢å å¼è°ƒåº¦å™¨ï¼Œè®©å¤šä»»åŠ¡çœŸæ­£å…¬å¹³è¿è¡Œï¼â€**

åœ¨ç¬¬å…­ç¯‡ä¸­ï¼Œæˆ‘ä»¬å®žçŽ°äº†**åä½œå¼å¤šä»»åŠ¡**ï¼Œè¿›ç¨‹é€šè¿‡ `yield()` ä¸»åŠ¨åˆ‡æ¢ã€‚  
ä½†è¿™æœ‰ä¸ªè‡´å‘½ç¼ºé™·ï¼š**ä¸€ä¸ªæ­»å¾ªçŽ¯çš„ç”¨æˆ·ç¨‹åºä¼šè®©æ•´ä¸ªç³»ç»Ÿæ— å“åº”**ï¼

çœŸæ­£çš„æ“ä½œç³»ç»Ÿå¿…é¡»èƒ½**å¼ºåˆ¶å‰¥å¤º CPU**ï¼Œåœ¨å¤šä¸ªä»»åŠ¡é—´å…¬å¹³åˆ†é…æ—¶é—´â€”â€”  
è¿™å°±æ˜¯ **æŠ¢å å¼è°ƒåº¦ï¼ˆPreemptive Schedulingï¼‰**ã€‚

ä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥ï¼š  
âœ… **å¯ç”¨æ—¶é’Ÿä¸­æ–­ï¼ˆPITï¼‰**  
âœ… **å®žçŽ°æ—¶é—´ç‰‡è½®è½¬ï¼ˆRound-Robinï¼‰è°ƒåº¦å™¨**  
âœ… **æ”¯æŒè¿›ç¨‹ä¼˜å…ˆçº§ä¸Žç¡çœ é˜Ÿåˆ—**  

è®©ä½ çš„ OS æ‹¥æœ‰**çœŸæ­£çš„å¹¶å‘èƒ½åŠ›**ï¼

---

## â±ï¸ ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦æŠ¢å å¼è°ƒåº¦ï¼Ÿ

### åä½œå¼è°ƒåº¦çš„ç—›ç‚¹ï¼š
| é—®é¢˜ | åŽæžœ |
|------|------|
| **ç”¨æˆ·ç¨‹åºæ­»å¾ªçŽ¯** | ç³»ç»Ÿå®Œå…¨å¡æ­»ï¼Œæ— æ³•å“åº” |
| **I/O å¯†é›†åž‹ä»»åŠ¡** | ä¸»åŠ¨è®©å‡ºé¢‘ç¹ï¼ŒCPU åˆ©ç”¨çŽ‡ä½Ž |
| **å®žæ—¶æ€§å·®** | æ— æ³•ä¿è¯å…³é”®ä»»åŠ¡åŠæ—¶æ‰§è¡Œ |

### æŠ¢å å¼è°ƒåº¦çš„ä¼˜åŠ¿ï¼š
- **å…¬å¹³æ€§**ï¼šæ¯ä¸ªè¿›ç¨‹èŽ·å¾—å›ºå®šæ—¶é—´ç‰‡ï¼ˆå¦‚ 10msï¼‰
- **å“åº”æ€§**ï¼šå³ä½¿æœ‰æ­»å¾ªçŽ¯ï¼Œç³»ç»Ÿä»å¯å“åº”
- **å¯æŽ§æ€§**ï¼šé€šè¿‡ä¼˜å…ˆçº§æŽ§åˆ¶ä»»åŠ¡æ‰§è¡Œé¡ºåº

> ðŸ’¡ **è°ƒåº¦å™¨æ˜¯æ“ä½œç³»ç»Ÿçš„â€œäº¤é€šè­¦å¯Ÿâ€ï¼Œå†³å®šè°åœ¨ä½•æ—¶ä½¿ç”¨ CPU**ã€‚

---

## ðŸ•°ï¸ äºŒã€æ—¶é’Ÿä¸­æ–­ï¼šè°ƒåº¦å™¨çš„å¿ƒè·³

x86 PC é€šè¿‡ **PITï¼ˆProgrammable Interval Timerï¼‰** äº§ç”Ÿå‘¨æœŸæ€§ä¸­æ–­ã€‚

### PIT åˆå§‹åŒ–ï¼š
```c
#define PIT_CHANNEL0 0x40
#define PIT_COMMAND  0x43
#define PIT_HZ       100  // 100 Hz = æ¯ 10ms ä¸€æ¬¡ä¸­æ–­

void pit_init() {
    // è®¾ç½® PIT é¢‘çŽ‡ï¼š1193180 / freq
    uint32_t divisor = 1193180 / PIT_HZ;
    outb(PIT_COMMAND, 0x36); // Channel 0, LSB/MSB, mode 3, binary
    outb(PIT_CHANNEL0, divisor & 0xFF);
    outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF);
}
```

### æ³¨å†Œæ—¶é’Ÿä¸­æ–­å¤„ç†ç¨‹åºï¼š
```c
// IDT ä¸­æ³¨å†Œ IRQ0ï¼ˆPIT ä¸­æ–­å‘é‡ = 32ï¼‰
idt_set_gate(32, (uint32_t)timer_handler, 0x08, 0x8E);

void timer_handler() {
    // 1. å‘é€ EOI åˆ° PIC
    outb(0x20, 0x20);
    
    // 2. æ›´æ–°ç³»ç»Ÿæ—¶é—´
    ticks++;
    
    // 3. è§¦å‘è°ƒåº¦ï¼ˆå…³é”®ï¼ï¼‰
    scheduler_tick();
}
```

> ðŸ”‘ **æ¯æ¬¡æ—¶é’Ÿä¸­æ–­ï¼Œéƒ½æ˜¯è°ƒåº¦å™¨æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢ä»»åŠ¡çš„æœºä¼š**ï¼

---

## ðŸ”„ ä¸‰ã€æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦å™¨

### 1. **è¿›ç¨‹ PCB å¢žåŠ è°ƒåº¦å­—æ®µ**
```c
typedef struct task {
    // ... å…¶ä»–å­—æ®µ
    int priority;           // ä¼˜å…ˆçº§ï¼ˆæš‚æœªä½¿ç”¨ï¼‰
    int time_slice;         // å½“å‰å‰©ä½™æ—¶é—´ç‰‡
    int default_time_slice; // é»˜è®¤æ—¶é—´ç‰‡ï¼ˆå¦‚ 5ï¼‰
    struct task *next;      // è¿è¡Œé˜Ÿåˆ—é“¾è¡¨
} task_t;
```

### 2. **è°ƒåº¦å™¨æ ¸å¿ƒï¼šscheduler_tick**
```c
void scheduler_tick() {
    task_t *current = current_task;
    
    // 1. å‡å°‘å½“å‰è¿›ç¨‹æ—¶é—´ç‰‡
    current->time_slice--;
    
    // 2. å¦‚æžœæ—¶é—´ç‰‡ç”¨å®Œï¼Œæ ‡è®°éœ€è¦è°ƒåº¦
    if (current->time_slice <= 0) {
        need_resched = 1;
    }
}
```

### 3. **ä»»åŠ¡åˆ‡æ¢ï¼šschedule**
```c
void schedule() {
    if (!need_resched) return;
    
    need_resched = 0;
    
    // 1. å°†å½“å‰è¿›ç¨‹æ”¾å›žè¿è¡Œé˜Ÿåˆ—å°¾éƒ¨
    if (current_task->state == TASK_RUNNING) {
        append_to_run_queue(current_task);
    }
    
    // 2. ä»Žè¿è¡Œé˜Ÿåˆ—å¤´éƒ¨å–ä¸‹ä¸€ä¸ªè¿›ç¨‹
    task_t *next = get_next_runnable_task();
    if (!next) return; // æ²¡æœ‰å¯è¿è¡Œè¿›ç¨‹
    
    // 3. é‡ç½®æ—¶é—´ç‰‡
    next->time_slice = next->default_time_slice;
    
    // 4. åˆ‡æ¢è¿›ç¨‹
    switch_to_task(next);
}
```

> âœ… **æ—¶é—´ç‰‡ç”¨å®Œ â†’ å½“å‰è¿›ç¨‹æŽ’é˜Ÿ â†’ åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªè¿›ç¨‹**

---

## ðŸ›Œ å››ã€ç¡çœ ä¸Žå”¤é†’ï¼šæ”¯æŒé˜»å¡žæ“ä½œ

è¿›ç¨‹å¯èƒ½å›  I/Oï¼ˆå¦‚è¯»é”®ç›˜ï¼‰è€Œ**ä¸»åŠ¨ç¡çœ **ï¼Œæ­¤æ—¶ä¸åº”å ç”¨ CPUã€‚

### 1. **ç¡çœ é˜Ÿåˆ—**
```c
struct sleep_queue {
    struct task *head;
    struct task *tail;
};

// æŒ‰äº‹ä»¶ç±»åž‹ç»„ç»‡ç¡çœ é˜Ÿåˆ—ï¼ˆç®€åŒ–ï¼šå…¨å±€ä¸€ä¸ªï¼‰
struct sleep_queue global_sleep_queue;
```

### 2. **ç¡çœ ï¼ˆsleep_onï¼‰**
```c
void sleep_on(struct sleep_queue *q) {
    // 1. å°†å½“å‰è¿›ç¨‹åŠ å…¥ç¡çœ é˜Ÿåˆ—
    if (!q->head) {
        q->head = q->tail = current_task;
    } else {
        q->tail->next = current_task;
        q->tail = current_task;
    }
    
    // 2. æ ‡è®°ä¸ºç¡çœ çŠ¶æ€
    current_task->state = TASK_SLEEPING;
    
    // 3. è§¦å‘è°ƒåº¦
    schedule();
}
```

### 3. **å”¤é†’ï¼ˆwake_upï¼‰**
```c
void wake_up(struct sleep_queue *q) {
    if (!q->head) return;
    
    // å”¤é†’æ‰€æœ‰ç¡çœ è¿›ç¨‹ï¼ˆç®€åŒ–ï¼šå®žé™…å¯å”¤é†’ä¸€ä¸ªï¼‰
    struct task *task = q->head;
    while (task) {
        task->state = TASK_RUNNING;
        append_to_run_queue(task);
        task = task->next;
    }
    
    q->head = q->tail = NULL;
}
```

### 4. **ç³»ç»Ÿè°ƒç”¨é›†æˆï¼šread é˜»å¡žç¤ºä¾‹**
```c
int sys_read(int fd, void *buf, size_t count) {
    // å¦‚æžœæ˜¯ stdin ä¸”æ— æ•°æ®
    if (fd == 0 && !uart_has_data()) {
        // ç¡çœ ç­‰å¾…æ•°æ®
        sleep_on(&uart_sleep_queue);
        // è¢«å”¤é†’åŽï¼Œç»§ç»­è¯»å–
    }
    // ... å®žé™…è¯»å–
}
```

> ðŸ’¡ **ä¸­æ–­å¤„ç†ç¨‹åºä¸­è°ƒç”¨ `wake_up`**ï¼ˆå¦‚ä¸²å£æ”¶åˆ°æ•°æ®æ—¶ï¼‰

---

## ðŸ§ª äº”ã€æµ‹è¯•ï¼šæŠ¢å å¼å¤šä»»åŠ¡

### ç”¨æˆ·ç¨‹åº 1ï¼ˆCPU å¯†é›†åž‹ï¼‰ï¼š
```c
void cpu_hog() {
    while (1) {
        // æ­»å¾ªçŽ¯ï¼Œä¸ä¸»åŠ¨ yield
        asm volatile ("nop");
    }
}
```

### ç”¨æˆ·ç¨‹åº 2ï¼ˆI/O å¯†é›†åž‹ï¼‰ï¼š
```c
void io_task() {
    char c;
    while (1) {
        read(0, &c, 1); // é˜»å¡žè¯» stdin
        write(1, &c, 1); // å›žæ˜¾
    }
}
```

### è¿è¡Œæ•ˆæžœï¼š
- å³ä½¿ `cpu_hog` æ­»å¾ªçŽ¯ï¼Œç³»ç»Ÿä»èƒ½å“åº”é”®ç›˜è¾“å…¥
- ä¸¤ä¸ªè¿›ç¨‹äº¤æ›¿è¿è¡Œï¼Œå„å çº¦ 50% CPU

âœ… **æŠ¢å å¼è°ƒåº¦æˆåŠŸï¼**

---

## ðŸ“Š å…­ã€è°ƒåº¦ç­–ç•¥æ‰©å±•

### 1. **ä¼˜å…ˆçº§è°ƒåº¦**
```c
// åœ¨ schedule() ä¸­ä¼˜å…ˆé€‰æ‹©é«˜ä¼˜å…ˆçº§è¿›ç¨‹
task_t *get_next_runnable_task() {
    task_t *best = NULL;
    for (task_t *t = run_queue; t; t = t->next) {
        if (!best || t->priority > best->priority) {
            best = t;
        }
    }
    return best;
}
```

### 2. **åŠ¨æ€ä¼˜å…ˆçº§**
- I/O å¯†é›†åž‹è¿›ç¨‹ â†’ æå‡ä¼˜å…ˆçº§ï¼ˆæé«˜å“åº”æ€§ï¼‰
- CPU å¯†é›†åž‹è¿›ç¨‹ â†’ é™ä½Žä¼˜å…ˆçº§ï¼ˆé¿å…éœ¸å  CPUï¼‰

### 3. **å¤šçº§åé¦ˆé˜Ÿåˆ—ï¼ˆMLFQï¼‰**
- å¤šä¸ªä¼˜å…ˆçº§é˜Ÿåˆ—
- æ—¶é—´ç‰‡ç”¨å®Œ â†’ é™çº§åˆ°ä½Žä¼˜å…ˆçº§é˜Ÿåˆ—
- I/O é˜»å¡žåŽå”¤é†’ â†’ å‡çº§åˆ°é«˜ä¼˜å…ˆçº§é˜Ÿåˆ—

> ðŸ’¡ **Linux çš„ CFSï¼ˆå®Œå…¨å…¬å¹³è°ƒåº¦å™¨ï¼‰æ˜¯æ›´é«˜çº§çš„å®žçŽ°**ã€‚

---

## âš ï¸ ä¸ƒã€å…³é”®æ³¨æ„äº‹é¡¹

1. **ä¸­æ–­ä¸Šä¸‹æ–‡ vs è¿›ç¨‹ä¸Šä¸‹æ–‡**  
   - è°ƒåº¦å™¨**ä¸èƒ½åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­ç›´æŽ¥è°ƒç”¨ `switch_to_task`**  
   - æ­£ç¡®åšæ³•ï¼šè®¾ç½® `need_resched`ï¼Œåœ¨ä¸­æ–­è¿”å›žå‰æ£€æŸ¥

2. **ä¸´ç•ŒåŒºä¿æŠ¤**  
   - è®¿é—®è¿è¡Œé˜Ÿåˆ—/ç¡çœ é˜Ÿåˆ—æ—¶ï¼Œéœ€**å…³é—­ä¸­æ–­**ï¼ˆ`cli`/`sti`ï¼‰

3. **ç©ºé—²è¿›ç¨‹ï¼ˆidle taskï¼‰**  
   - å½“æ— ä»»åŠ¡å¯è¿è¡Œæ—¶ï¼Œæ‰§è¡Œ `hlt` æŒ‡ä»¤èŠ‚çœåŠŸè€—

4. **è°ƒåº¦å»¶è¿Ÿ**  
   - æ—¶é—´ç‰‡å¤ªçŸ­ â†’ è°ƒåº¦å¼€é”€å¤§  
   - æ—¶é—´ç‰‡å¤ªé•¿ â†’ å“åº”æ€§å·®  
   - é€šå¸¸ 1~10ms ä¸ºå®œ

---

## ðŸ’¬ å†™åœ¨æœ€åŽ

è°ƒåº¦å™¨æ˜¯æ“ä½œç³»ç»Ÿçš„**å¿ƒè„**ï¼Œ  
å®ƒå†³å®šäº†ä»»åŠ¡å¦‚ä½•å…±äº« CPU è¿™ä¸€ç¨€ç¼ºèµ„æºã€‚  
ä»Žåä½œå¼åˆ°æŠ¢å å¼ï¼Œ  
ä¸ä»…æ˜¯æŠ€æœ¯çš„æ¼”è¿›ï¼Œæ›´æ˜¯**è®¾è®¡ç†å¿µçš„è·ƒè¿**ã€‚

ä»Šå¤©ä½ å®žçŽ°çš„ `scheduler_tick`ï¼Œ  
æ­£æ˜¯ Linux ä¸­ `scheduler_tick` å’Œ `__schedule` çš„é›å½¢ã€‚

> ðŸŒŸ **å…¬å¹³ã€é«˜æ•ˆã€å“åº”è¿…é€Ÿâ€”â€”è¿™æ˜¯è°ƒåº¦å™¨æ°¸æ’çš„è¿½æ±‚ã€‚**

---

ðŸ“¬ **åŠ¨æ‰‹æŒ‘æˆ˜**ï¼š  
å®žçŽ°ä¸€ä¸ªç®€å•çš„ä¼˜å…ˆçº§ç³»ç»Ÿï¼Œè®© I/O å¯†é›†åž‹è¿›ç¨‹èŽ·å¾—æ›´é«˜ä¼˜å…ˆçº§ã€‚  
æ¬¢è¿Žåœ¨è¯„è®ºåŒºåˆ†äº«ä½ çš„è°ƒåº¦ç­–ç•¥ï¼

ðŸ‘‡ ä¸‹ä¸€ç¯‡ä½ æƒ³çœ‹ï¼š**å¤šå¤„ç†å™¨ï¼ˆSMPï¼‰æ”¯æŒ**ï¼Œè¿˜æ˜¯ **è¿›ç¨‹é—´é€šä¿¡ï¼ˆç®¡é“/Pipeï¼‰**ï¼Ÿ

---

**#æ“ä½œç³»ç»Ÿ #å†…æ ¸å¼€å‘ #è°ƒåº¦å™¨ #æŠ¢å å¼è°ƒåº¦ #æ—¶é’Ÿä¸­æ–­ #PIT #å¤šä»»åŠ¡ #ä»Žé›¶å¼€å§‹**

---

> ðŸ“¢ **å½©è›‹**ï¼šå…³æ³¨åŽå›žå¤å…³é”®è¯ **â€œschedulerâ€**ï¼ŒèŽ·å–ï¼š
> - å®Œæ•´æŠ¢å å¼è°ƒåº¦å™¨ä»£ç ï¼ˆå« PIT åˆå§‹åŒ–ï¼‰
> - ç¡çœ /å”¤é†’æœºåˆ¶å®žçŽ°
> - æ—¶é—´ç‰‡è½®è½¬ä¸Žä¼˜å…ˆçº§è°ƒåº¦å¯¹æ¯”æµ‹è¯•
