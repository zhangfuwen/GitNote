# ä»é›¶å†™ OS å†…æ ¸-ç¬¬åå…«ç¯‡ï¼šå¤šæ ¸æ”¯æŒ â€”â€” è®©ä½ çš„ OS çœŸæ­£å¹¶è¡Œèµ·æ¥ï¼

> **â€œå•æ ¸è°ƒåº¦åªæ˜¯ä¼ªå¹¶å‘ï¼ŒçœŸæ­£çš„æ€§èƒ½é£è·ƒåœ¨å¤šæ ¸ï¼  
> ä»Šå¤©ï¼Œæˆ‘ä»¬å”¤é†’æ‰€æœ‰ CPU æ ¸å¿ƒï¼Œå®ç° SMPï¼ˆå¯¹ç§°å¤šå¤„ç†ï¼‰æ”¯æŒï¼â€**

åœ¨ä¸Šä¸€ç¯‡ä¸­ï¼Œæˆ‘ä»¬å®ç°äº†**æŠ¢å å¼è°ƒåº¦å™¨**ï¼Œä½†æ‰€æœ‰ä»»åŠ¡ä»åœ¨**å•ä¸ª CPU æ ¸å¿ƒ**ä¸Šåˆ‡æ¢ã€‚  
è€Œç°ä»£å¤„ç†å™¨æ™®éæ˜¯å¤šæ ¸ï¼ˆåŒæ ¸ã€å››æ ¸ç”šè‡³æ›´å¤šï¼‰ï¼Œ  
çœŸæ­£çš„æ“ä½œç³»ç»Ÿå¿…é¡»èƒ½**åˆ©ç”¨æ‰€æœ‰æ ¸å¿ƒ**ï¼Œå®ç°**çœŸæ­£çš„å¹¶è¡Œè®¡ç®—**ã€‚

ä»Šå¤©ï¼Œæˆ‘ä»¬å°±æ¥ï¼š  
âœ… **è§£æå¤šæ ¸å¯åŠ¨åè®®ï¼ˆAP å¯åŠ¨æµç¨‹ï¼‰**  
âœ… **å®ç°æ ¸é—´é€šä¿¡ä¸åŒæ­¥åŸè¯­**  
âœ… **æ”¹é€ è°ƒåº¦å™¨æ”¯æŒå¤šæ ¸è°ƒåº¦**  

è®©ä½ çš„ OS åœ¨å¤šæ ¸ CPU ä¸ŠçœŸæ­£â€œç«åŠ›å…¨å¼€â€ï¼

---

## ğŸ§© ä¸€ã€x86 å¤šæ ¸å¯åŠ¨åŸºç¡€ï¼šBSP ä¸ AP

x86 å¤šå¤„ç†å™¨ç³»ç»Ÿå¯åŠ¨æ—¶ï¼š
- **BSPï¼ˆBootstrap Processorï¼‰**ï¼šç¬¬ä¸€ä¸ªå¯åŠ¨çš„æ ¸å¿ƒï¼ˆé€šå¸¸æ˜¯ Core 0ï¼‰
- **APï¼ˆApplication Processorï¼‰**ï¼šå…¶ä»–æ ¸å¿ƒï¼Œåˆå§‹å¤„äº**ä¼‘çœ çŠ¶æ€**

### å¯åŠ¨ AP çš„æ ‡å‡†åè®®ï¼š**MP Specification** æˆ– **ACPI MADT**  
ä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨ **Intel MultiProcessor Specification (MP Spec)**ã€‚

### å…³é”®æ­¥éª¤ï¼š
1. **BSP è§£æ MP è¡¨**ï¼Œè·å– CPU æ ¸å¿ƒæ•°é‡å’Œ LAPIC ID
2. **BSP é€šè¿‡ LAPIC å‘é€ INIT/SIPI æ¶ˆæ¯** å”¤é†’ AP
3. **AP ä»æŒ‡å®šåœ°å€å¼€å§‹æ‰§è¡Œ**ï¼ˆé€šå¸¸æ˜¯ 0x10000ï¼‰

> ğŸ’¡ **LAPICï¼ˆLocal APICï¼‰** æ˜¯æ¯ä¸ªæ ¸å¿ƒçš„ä¸­æ–­æ§åˆ¶å™¨ï¼Œä¹Ÿæ˜¯æ ¸é—´é€šä¿¡çš„å…³é”®ã€‚

---

## ğŸ”Œ äºŒã€LAPIC åˆå§‹åŒ–ä¸ AP å¯åŠ¨

### 1. **å¯ç”¨ LAPIC**
```c
void lapic_init() {
    // 1. æ£€æŸ¥ CPU æ˜¯å¦æ”¯æŒ APIC
    if (!(cpuid_features() & CPUID_FEAT_EDX_APIC)) {
        panic("APIC not supported!");
    }
    
    // 2. å¯ç”¨ APICï¼ˆè®¾ç½® IA32_APIC_BASE MSRï¼‰
    uint64_t apic_base = rdmsr(MSR_IA32_APIC_BASE);
    apic_base |= APIC_ENABLE_BIT;
    wrmsr(MSR_IA32_APIC_BASE, apic_base);
    
    // 3. æ˜ å°„ LAPIC å¯„å­˜å™¨åˆ°è™šæ‹Ÿåœ°å€
    lapic_base_vaddr = 0xFEE00000; // é»˜è®¤ç‰©ç†åœ°å€
    map_kernel_page(lapic_base_vaddr, lapic_base_vaddr, PAGE_PRESENT | PAGE_RW);
}
```

### 2. **è§£æ MP Floating Pointer**
```c
struct mp_floating_pointer {
    char signature[4]; // "_MP_"
    uint32_t mp_table;
    // ... å…¶ä»–å­—æ®µ
};

void mp_parse() {
    // åœ¨ 0x0009FC00 - 0x0009FFFF æˆ– 0xF0000 - 0xFFFFF æ‰«æ
    for (uint32_t addr = 0x9FC00; addr < 0xA0000; addr += 16) {
        struct mp_floating_pointer *fp = (void*)addr;
        if (memcmp(fp->signature, "_MP_", 4) == 0) {
            mp_table = (void*)fp->mp_table;
            break;
        }
    }
    
    // è§£æ CPU æ¡ç›®
    cpu_count = 0;
    for (struct mp_config_table_entry *entry = mp_table->entries; 
         (void*)entry < (void*)mp_table + mp_table->length; 
         entry = next_entry(entry)) {
        if (entry->type == MP_CPU) {
            cpu_info[cpu_count].apic_id = entry->cpu.apic_id;
            cpu_info[cpu_count].bsp = entry->cpu.cpu_flags & 1;
            cpu_count++;
        }
    }
}
```

### 3. **å¯åŠ¨ AP æ ¸å¿ƒ**
```c
void ap_start(uint8_t apic_id, uint32_t startup_addr) {
    // 1. å‘é€ INIT IPI
    lapic_write(LAPIC_ICR1, apic_id << 24);
    lapic_write(LAPIC_ICR, APIC_ICR_INIT | APIC_ICR_ASSERT | APIC_ICR_LEVEL_TRIGGER);
    delay(10000); // ç­‰å¾… INIT å®Œæˆ
    
    // 2. å‘é€ SIPIï¼ˆStartup IPIï¼‰
    uint8_t vector = startup_addr >> 12; // Startup é¡µï¼ˆ4KB å¯¹é½ï¼‰
    lapic_write(LAPIC_ICR1, apic_id << 24);
    lapic_write(LAPIC_ICR, APIC_ICR_STARTUP | APIC_ICR_ASSERT | vector);
}
```

---

## ğŸ§± ä¸‰ã€AP å¯åŠ¨ä»£ç ï¼ˆæ±‡ç¼–ï¼‰

AP ä»å®æ¨¡å¼å¼€å§‹æ‰§è¡Œï¼Œéœ€è¦ï¼š
1. **è®¾ç½®ä¿æŠ¤æ¨¡å¼**
2. **å¯ç”¨åˆ†é¡µ**
3. **è·³è½¬åˆ° C ä»£ç **

```nasm
section .text
align 4096
ap_startup:
    ; å®æ¨¡å¼ä¸‹ï¼ŒCS=0x1000, IP=0
    cli
    lgdt [gdtr]          ; åŠ è½½ GDTï¼ˆä¸ BSP å…±äº«ï¼‰
    
    ; è¿›å…¥ä¿æŠ¤æ¨¡å¼
    mov eax, cr0
    or eax, 1
    mov cr0, eax
    jmp 0x08:ap_pm       ; è¿œè·³è½¬åˆ·æ–° CS

[bits 32]
ap_pm:
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; å¯ç”¨åˆ†é¡µï¼ˆä½¿ç”¨ BSP çš„é¡µç›®å½•ï¼‰
    mov eax, cr3_bsp     ; BSP çš„é¡µç›®å½•ç‰©ç†åœ°å€
    mov cr3, eax
    mov eax, cr0
    or eax, 0x80000000   ; è®¾ç½® PG ä½
    mov cr0, eax
    
    ; è·³è½¬åˆ° C å…¥å£
    jmp ap_main
```

> ğŸ”‘ **AP ä½¿ç”¨ä¸ BSP ç›¸åŒçš„ GDT å’Œé¡µç›®å½•**ï¼ˆç®€åŒ–è®¾è®¡ï¼‰ã€‚

---

## ğŸ”’ å››ã€æ ¸é—´åŒæ­¥ï¼šè‡ªæ—‹é”ä¸åŸå­æ“ä½œ

å¤šæ ¸å¹¶å‘è®¿é—®å…±äº«æ•°æ®æ—¶ï¼Œå¿…é¡»åŒæ­¥ï¼

### 1. **åŸå­æ“ä½œï¼ˆå†…è”æ±‡ç¼–ï¼‰**
```c
static inline bool atomic_cas(volatile uint32_t *ptr, uint32_t expected, uint32_t desired) {
    uint32_t result;
    asm volatile (
        "lock cmpxchg %2, %1"
        : "=a"(result), "+m"(*ptr)
        : "r"(desired), "a"(expected)
        : "memory"
    );
    return result == expected;
}
```

### 2. **è‡ªæ—‹é”ï¼ˆSpinlockï¼‰**
```c
typedef struct spinlock {
    volatile uint32_t lock;
} spinlock_t;

#define SPINLOCK_INIT {0}

static inline void spinlock_init(spinlock_t *lock) {
    lock->lock = 0;
}

static inline void spinlock_acquire(spinlock_t *lock) {
    while (!atomic_cas(&lock->lock, 0, 1)) {
        // è‡ªæ—‹ç­‰å¾…
        asm volatile ("pause" ::: "memory");
    }
}

static inline void spinlock_release(spinlock_t *lock) {
    asm volatile ("" ::: "memory"); // å†…å­˜å±éšœ
    lock->lock = 0;
}
```

> âš ï¸ **è‡ªæ—‹é”æŒæœ‰æœŸé—´å¿…é¡»å…³é—­ä¸­æ–­**ï¼ˆé¿å…æ­»é”ï¼‰ï¼

---

## ğŸ”„ äº”ã€å¤šæ ¸è°ƒåº¦å™¨æ”¹é€ 

### 1. **æ¯ä¸ªæ ¸å¿ƒç‹¬ç«‹çš„è¿è¡Œé˜Ÿåˆ—**
```c
typedef struct percpu_data {
    task_t *current_task;
    task_t *run_queue;
    spinlock_t run_queue_lock;
    // ... å…¶ä»– per-CPU æ•°æ®
} percpu_data_t;

// æ¯ä¸ªæ ¸å¿ƒä¸€ä¸ª
percpu_data_t percpu[MAX_CPUS];
```

### 2. **è·å–å½“å‰æ ¸å¿ƒ ID**
```c
static inline uint8_t get_cpu_id() {
    uint32_t lo, hi;
    asm volatile ("rdtscp" : "=a"(lo), "=d"(hi) :: "rcx");
    return (hi >> 24) & 0xFF; // ä» TSC_AUX è·å–
}
```

### 3. **è°ƒåº¦å™¨å‡½æ•°æ”¹é€ **
```c
void schedule() {
    uint8_t cpu = get_cpu_id();
    percpu_data_t *pcpu = &percpu[cpu];
    
    spinlock_acquire(&pcpu->run_queue_lock);
    
    // ä»æœ¬æ ¸å¿ƒè¿è¡Œé˜Ÿåˆ—å–ä»»åŠ¡
    task_t *next = get_next_task(pcpu->run_queue);
    if (next) {
        pcpu->current_task = next;
        switch_to_task(next);
    }
    
    spinlock_release(&pcpu->run_queue_lock);
}
```

### 4. **è´Ÿè½½å‡è¡¡ï¼ˆå¯é€‰ï¼‰**
- å®šæœŸæ£€æŸ¥å…¶ä»–æ ¸å¿ƒçš„è¿è¡Œé˜Ÿåˆ—
- å¦‚æœè´Ÿè½½ä¸å‡ï¼Œè¿ç§»ä»»åŠ¡

---

## ğŸ“ å…­ã€æ ¸é—´ä¸­æ–­ï¼ˆIPIï¼‰ï¼šæ ¸å¿ƒé—´é€šä¿¡

LAPIC æ”¯æŒ**æ ¸é—´ä¸­æ–­ï¼ˆIPIï¼‰**ï¼Œç”¨äºï¼š
- **è°ƒåº¦è¯·æ±‚**ï¼šä¸€ä¸ªæ ¸å¿ƒå”¤é†’å¦ä¸€ä¸ªæ ¸å¿ƒ
- **TLB åˆ·æ–°**ï¼šä¸€ä¸ªæ ¸å¿ƒä¿®æ”¹é¡µè¡¨åé€šçŸ¥å…¶ä»–æ ¸å¿ƒ
- **å…³æœº/é‡å¯**

```c
void send_ipi(uint8_t target_apic_id, uint8_t vector) {
    lapic_write(LAPIC_ICR1, target_apic_id << 24);
    lapic_write(LAPIC_ICR, APIC_ICR_FIXED | APIC_ICR_ASSERT | vector);
}
```

### ç¤ºä¾‹ï¼šTLB åˆ·æ–°
```c
void flush_tlb_others() {
    for (int i = 0; i < cpu_count; i++) {
        if (i != get_cpu_id()) {
            send_ipi(cpu_info[i].apic_id, TLB_FLUSH_IPI_VECTOR);
        }
    }
}
```

---

## ğŸ§ª ä¸ƒã€æµ‹è¯•ï¼šå¤šæ ¸å¹¶è¡Œè®¡ç®—

### ç”¨æˆ·ç¨‹åºï¼š
```c
void worker() {
    uint64_t sum = 0;
    for (volatile int i = 0; i < 100000000; i++) {
        sum += i;
    }
    printf("Core %d: sum = %llu\n", get_core_id(), sum);
}
```

### å†…æ ¸ï¼š
- å¯åŠ¨ 4 ä¸ªè¿›ç¨‹ï¼Œç»‘å®šåˆ°ä¸åŒæ ¸å¿ƒ
- è§‚å¯Ÿ QEMU çš„ `-smp 4` è¾“å‡º

è¿è¡Œæ•ˆæœï¼š
```
Core 0: sum = 4999999950000000
Core 1: sum = 4999999950000000
Core 2: sum = 4999999950000000
Core 3: sum = 4999999950000000
```

âœ… **å››ä¸ªæ ¸å¿ƒåŒæ—¶è®¡ç®—ï¼Œæ€»æ—¶é—´çº¦ä¸ºå•æ ¸çš„ 1/4ï¼**

---

## âš ï¸ ä¸ƒã€å¤šæ ¸ç¼–ç¨‹çš„é™·é˜±

1. **ä¼ªå…±äº«ï¼ˆFalse Sharingï¼‰**  
   - ä¸åŒæ ¸å¿ƒä¿®æ”¹åŒä¸€ç¼“å­˜è¡Œçš„ä¸åŒå˜é‡  
   - è§£å†³æ–¹æ¡ˆï¼š**ç¼“å­˜è¡Œå¯¹é½**ï¼ˆ`__attribute__((aligned(64)))`ï¼‰

2. **å†…å­˜å±éšœ**  
   - å¤šæ ¸ä¸‹ CPU å’Œç¼–è¯‘å™¨ä¼šé‡æ’åºæŒ‡ä»¤  
   - å…³é”®æ“ä½œéœ€åŠ  `mfence`/`sfence`/`lfence`

3. **æ­»é”**  
   - å¤šä¸ªé”çš„è·å–é¡ºåºå¿…é¡»ä¸€è‡´  
   - ä½¿ç”¨**é”å±‚çº§**ï¼ˆLock Orderingï¼‰é¿å…

4. **ä¸­æ–­äº²å’Œæ€§**  
   - å°†è®¾å¤‡ä¸­æ–­ç»‘å®šåˆ°ç‰¹å®šæ ¸å¿ƒï¼Œå‡å°‘è·¨æ ¸åŒæ­¥

> ğŸ’¡ **å¤šæ ¸ç¼–ç¨‹çš„é»„é‡‘æ³•åˆ™ï¼šå°½é‡å‡å°‘å…±äº«çŠ¶æ€ï¼Œç”¨æ¶ˆæ¯ä¼ é€’ä»£æ›¿å…±äº«å†…å­˜ï¼**

---

## ğŸ’¬ å†™åœ¨æœ€å

å¤šæ ¸æ”¯æŒæ˜¯æ“ä½œç³»ç»Ÿä»â€œç©å…·â€èµ°å‘â€œç”Ÿäº§çº§â€çš„å…³é”®ä¸€æ­¥ã€‚  
å®ƒä¸ä»…æ˜¯æ€§èƒ½çš„æå‡ï¼Œæ›´æ˜¯**å¹¶å‘æ€ç»´çš„é©å‘½**ã€‚

ä»Šå¤©ä½ å”¤é†’çš„ç¬¬äºŒä¸ª CPU æ ¸å¿ƒï¼Œ  
æ­£æ˜¯ç°ä»£æ•°æ®ä¸­å¿ƒæ•°ç™¾ä¸‡æ ¸å¿ƒå¹¶è¡Œè®¡ç®—çš„èµ·ç‚¹ã€‚

> ğŸŒŸ **å¹¶è¡Œä¸æ˜¯é€‰æ‹©ï¼Œè€Œæ˜¯å¿…ç„¶â€”â€”å› ä¸ºå•æ ¸æ€§èƒ½æ—©å·²åœæ»ã€‚**

---

ğŸ“¬ **åŠ¨æ‰‹æŒ‘æˆ˜**ï¼š  
åœ¨ QEMU ä¸­å¯åŠ¨ 4 æ ¸ï¼Œåˆ›å»º 4 ä¸ªè®¡ç®—å¯†é›†å‹è¿›ç¨‹ï¼ŒéªŒè¯åŠ é€Ÿæ¯”ã€‚  
æ¬¢è¿åœ¨è¯„è®ºåŒºåˆ†äº«ä½ çš„å¤šæ ¸æ€§èƒ½æµ‹è¯•ç»“æœï¼

ğŸ‘‡ ä¸‹ä¸€ç¯‡ä½ æƒ³çœ‹ï¼š**è¿›ç¨‹é—´é€šä¿¡ï¼ˆç®¡é“/Pipeï¼‰**ï¼Œè¿˜æ˜¯ **ä¿¡å·ï¼ˆSignalï¼‰æœºåˆ¶**ï¼Ÿ

---

**#æ“ä½œç³»ç»Ÿ #å†…æ ¸å¼€å‘ #å¤šæ ¸ #SMP #LAPIC #è°ƒåº¦å™¨ #å¹¶è¡Œè®¡ç®— #ä»é›¶å¼€å§‹**

---

> ğŸ“¢ **å½©è›‹**ï¼šå…³æ³¨åå›å¤å…³é”®è¯ **â€œsmpâ€**ï¼Œè·å–ï¼š
> - å®Œæ•´å¤šæ ¸å¯åŠ¨ä»£ç ï¼ˆMP Spec è§£æ + AP å¯åŠ¨ï¼‰
> - è‡ªæ—‹é”ä¸åŸå­æ“ä½œå®ç°
> - å¤šæ ¸è°ƒåº¦å™¨æ”¹é€ æ¨¡æ¿
