
# 异常和中断

## 异常的入栈出栈流程

抱歉之前的内容仍存在混淆。按照栈“后进先出”的原则，在退出中断时，若存在错误码，确实应该先将错误码弹出。以下是完整且正确的进入中断和退出中断时的入栈出栈顺序表格：

### 进入中断（异常发生时）的入栈顺序（CPU 硬件行为）
| 步骤 | 操作内容 | 操作主体 | 操作前 `ESP` | 操作后 `ESP` | 栈中存储情况（从栈顶到栈底） |
| --- | --- | --- | --- | --- | --- |
| 1 | 压入 `EFLAGS` | CPU 硬件 | 0x20 | 0x1C | 地址 0x1C: `EFLAGS` |
| 2 | 压入 `CS` | CPU 硬件 | 0x1C | 0x18 | 地址 0x18: `CS`<br>地址 0x1C: `EFLAGS` |
| 3 | 压入 `EIP` | CPU 硬件 | 0x18 | 0x14 | 地址 0x14: `EIP`<br>地址 0x18: `CS`<br>地址 0x1C: `EFLAGS` |
| 4 | 压入错误码（若异常有） | CPU 硬件 | 0x14 | 0x10 | 地址 0x10: `错误码`<br>地址 0x14: `EIP`<br>地址 0x18: `CS`<br>地址 0x1C: `EFLAGS` |

### 退出中断（异常处理完成后）的出栈顺序
| 步骤 | 操作内容 | 操作主体 | 操作前 `ESP` | 操作后 `ESP` | 栈中剩余存储情况（从栈顶到栈底） |
| --- | --- | --- | --- | --- | --- |
| 1 | 弹出错误码（若有） | 程序代码（手动处理） | 0x10 | 0x14 | 地址 0x14: `EIP`<br>地址 0x18: `CS`<br>地址 0x1C: `EFLAGS` |
| 2 | 弹出 `EIP` | CPU 硬件（执行 `iret` 指令） | 0x14 | 0x18 | 地址 0x18: `CS`<br>地址 0x1C: `EFLAGS` |
| 3 | 弹出 `CS` | CPU 硬件（执行 `iret` 指令） | 0x18 | 0x1C | 地址 0x1C: `EFLAGS` |
| 4 | 弹出 `EFLAGS` | CPU 硬件（执行 `iret` 指令） | 0x1C | 0x20 | 无 |

### 解释
- **进入中断**：当异常发生时，CPU 硬件会自动按照 `EFLAGS`、`CS`、`EIP`、错误码（如果该异常产生错误码）的顺序将这些值压入栈中，以保存被中断程序的执行现场。
- **退出中断**：
    - 由于错误码是最后压入栈的，所以需要在程序代码中手动先将其弹出（例如使用 `add esp, 4` 指令跳过错误码，或者使用 `pop` 指令将其弹出）。
    - 之后执行 `iret` 指令，`iret` 指令会按照 `EIP`、`CS`、`EFLAGS` 的顺序从栈中弹出相应的值，从而恢复被中断程序的执行现场，使程序能够从中断处继续执行。 

## 所有异常列表

以下是 x86 架构中常见异常的详细信息表格，涵盖异常编号、名称、是否有错误码、进入中断和退出中断时的入栈出栈顺序等内容：

| 异常编号 | 异常名称 | 是否有错误码 | 进入中断入栈顺序（CPU 硬件行为） | 退出中断出栈顺序（程序代码手动处理 + CPU 硬件 `iret` 指令） | 简要说明 |
| --- | --- | --- | --- | --- | --- |
| 0 | 除法错误（Divide Error） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行除法指令（`DIV` 或 `IDIV`）时，除数为 0 或商无法表示时触发。 |
| 1 | 单步中断（Debug Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 用于调试，当 `EFLAGS` 寄存器中的单步标志（TF）置 1 时，每条指令执行后触发。 |
| 2 | 非屏蔽中断（NMI Interrupt） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 由硬件触发的非屏蔽中断，通常用于处理紧急情况，如硬件故障。 |
| 3 | 断点中断（Breakpoint Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行 `INT 3` 指令时触发，用于调试。 |
| 4 | 溢出中断（Overflow Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行 `INTO` 指令且 `EFLAGS` 寄存器中的溢出标志（OF）置 1 时触发。 |
| 5 | 边界检查异常（BOUND Range Exceeded Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行 `BOUND` 指令时，操作数超出指定范围触发。 |
| 6 | 无效操作码异常（Invalid Opcode Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | CPU 遇到无法识别的操作码时触发。 |
| 7 | 设备不可用异常（Device Not Available Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行浮点运算指令，但协处理器不可用时触发。 |
| 8 | 双重故障异常（Double Fault Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 尝试处理一个异常时，又发生另一个异常，且无法正确处理时触发。 |
| 9 | 协处理器段超越异常（Coprocessor Segment Overrun） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 早期 x86 架构中，浮点运算跨越段边界时触发，现代架构已较少使用。 |
| 10 | 无效 TSS 异常（Invalid TSS Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 任务切换时，TSS（任务状态段）无效或不可访问时触发。 |
| 11 | 段不存在异常（Segment Not Present Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 访问的段描述符的 `P`（存在位）为 0 时触发。 |
| 12 | 栈段异常（Stack-Segment Fault Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 访问栈段时发生错误，如栈溢出或栈段不存在时触发。 |
| 13 | 一般保护异常（General Protection Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 违反系统保护规则时触发，如访问权限不足等。 |
| 14 | 页错误异常（Page Fault Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 访问的页面不在物理内存中，触发页错误，需要进行页面置换等操作。 |
| 16 | 浮点错误异常（x87 FPU Floating-Point Error） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 执行 x87 浮点运算指令时发生错误。 |
| 17 | 对齐检查异常（Alignment Check Exception） | 是 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` <br> 4. 压入错误码 | 1. 手动弹出错误码 <br> 2. `iret` 弹出 `EIP` <br> 3. `iret` 弹出 `CS` <br> 4. `iret` 弹出 `EFLAGS` | 访问未对齐的内存地址时触发，需要启用对齐检查标志。 |
| 18 | 机器检查异常（Machine Check Exception） | 否 | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 硬件检测到内部错误，如总线错误、缓存错误等。 |
| 19 - 31 | 保留异常 | - | - | - | 为未来的 CPU 扩展保留。 |
| 32 - 255 | 可屏蔽中断（Interrupts） | 通常无（取决于中断处理程序设计） | 1. 压入 `EFLAGS` <br> 2. 压入 `CS` <br> 3. 压入 `EIP` | 1. `iret` 弹出 `EIP` <br> 2. `iret` 弹出 `CS` <br> 3. `iret` 弹出 `EFLAGS` | 由外部设备通过中断控制器发送的中断请求。 |

这个表格总结了 x86 架构中常见异常的关键信息，包括异常编号、名称、是否有错误码以及进入和退出中断时的栈操作顺序，同时对每个异常的触发条件做了简要说明。 


# iret指令
## 特权场景
 
抱歉，此前表格存在逻辑错误，现重新梳理修正（基于32位系统，按`iret`弹栈逻辑：先弹`EFLAGS`，再弹`CS`，最后弹`EIP`等，结合入栈顺序还原正确栈操作）：

| 操作阶段 | 操作步骤 | 操作内容       | 操作前 `ESP` 值 | 操作后 `ESP` 值 | 栈中存储情况（从栈顶到栈底）                     |
|----------|----------|----------------|------------------|------------------|--------------------------------------------------|
| 入栈     | 初始状态 | -              | 20               | 20               | 无                                               |
| 入栈     | 1        | `pushl $0x23`  | 20               | 16               | 地址 16: `SS`                                    |
| 入栈     | 2        | `pushl %%eax`  | 16               | 12               | 地址 12: `ESP`<br>地址 16: `SS`                 |
| 入栈     | 3        | `pushfl`       | 12               | 8                | 地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS` |
| 入栈     | 4        | `orl $0x200, (%%esp)` | 8    | 8                | 地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS` |
| 入栈     | 5        | `pushl $0x1B`  | 8                | 4                | 地址 4: `CS`<br>地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS` |
| 入栈     | 6        | `pushl %%ebx`  | 4                | 0                | 地址 0: `EIP`<br>地址 4: `CS`<br>地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS` |
| 弹栈     | 1        | 弹出 `EIP`     | 0                | 4                | 地址 4: `CS`<br>地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS`（弹出值：`EIP`） |
| 弹栈     | 2        | 弹出 `CS`      | 4                | 8                | 地址 8: `EFLAGS`<br>地址 12: `ESP`<br>地址 16: `SS`（弹出值：`CS`） |
| 弹栈     | 3        | 弹出 `EFLAGS`  | 8                | 12               | 地址 12: `ESP`<br>地址 16: `SS`（弹出值：`EFLAGS`） |
| 弹栈     | 4        | 弹出 `ESP`     | 12               | 16               | 地址 16: `SS`（弹出值：`ESP`）                   |
| 弹栈     | 5        | 弹出 `SS`      | 16               | 20               | 无（弹出值：`SS`）                               |

修正说明：  
1. `iret` 弹栈逻辑：按 `EIP` → `CS` → `EFLAGS` 顺序弹出（特权级切换场景），表格按此还原。  
2. 每步弹栈操作，优先弹出栈顶数据（即最后入栈的 `EIP` 最先被弹出）。





 
## 无特权切换场景

（`iret` 正常弹栈逻辑：先弹 `EIP`，再弹 `CS`，最后弹 `EFLAGS`）重新梳理，假设初始 `ESP = 20`，32 位系统下每步栈操作 `ESP` 增减 4：

| 操作阶段 | 操作步骤 | 操作内容              | 操作前 `ESP` 值 | 操作后 `ESP` 值 | 栈中存储情况（从栈顶到栈底）                     |
|----------|----------|-----------------------|------------------|------------------|--------------------------------------------------|
| 入栈     | 初始状态 | -                     | 20               | 20               | 无                                               |
| 入栈     | 1        | `pushfl`（压 `EFLAGS`） | 20               | 16               | 地址 16: `EFLAGS`                                |
| 入栈     | 2        | `pushl $0x1B`（压 `CS`） | 16               | 12               | 地址 12: `CS`<br>地址 16: `EFLAGS`             |
| 入栈     | 3        | `pushl %%ebx`（压 `EIP`） | 12               | 8                | 地址 8: `EIP`<br>地址 12: `CS`<br>地址 16: `EFLAGS` |
| 弹栈     | 1        | 弹出 `EIP`            | 8                | 12               | 地址 12: `CS`<br>地址 16: `EFLAGS`（弹出值：`EIP`） |
| 弹栈     | 2        | 弹出 `CS`             | 12               | 16               | 地址 16: `EFLAGS`（弹出值：`CS`）               |
| 弹栈     | 3        | 弹出 `EFLAGS`         | 16               | 20               | 无（弹出值：`EFLAGS`）                           |

关键逻辑说明：
- **入栈顺序**：按 `EFLAGS` → `CS` → `EIP` 压栈，栈顶地址逐步递减（20→16→12→8）。  
- **弹栈顺序**：`iret` 按 `EIP`（栈顶最先压入）→ `CS` → `EFLAGS` 弹出，栈顶地址逐步回增（8→12→16→20），最终恢复初始 `ESP` 值。

# iret, iretd, iretq区别

`iret`、`iretd` 和 `iretq` 都是用于从中断或异常处理程序返回的指令，不过它们在不同的架构和操作数大小方面存在差异，下面为你详细介绍：

### 1. 操作数大小与架构
- **`iret`**
    - **适用架构**：它是一个通用的中断返回指令，在 16 位和 32 位 x86 架构中都可以使用。
    - **操作数大小**：在 16 位模式下，`iret` 会弹出 6 个字节的数据，分别是 2 字节的 `IP`（指令指针）、2 字节的 `CS`（代码段寄存器）和 2 字节的 `FLAGS`（标志寄存器）；在 32 位模式下，它会弹出 12 个字节的数据，即 4 字节的 `EIP`、4 字节的 `CS` 和 4 字节的 `EFLAGS`。
 - **`iretd`**
    - **适用架构**：专门用于 32 位 x86 架构。
    - **操作数大小**：`iretd` 指令明确弹出 12 个字节的数据，具体为 4 字节的 `EIP`、4 字节的 `CS` 和 4 字节的 `EFLAGS`。在 32 位系统中，`iretd` 和 `iret` 的功能是一样的，只是 `iretd` 更清晰地表明是 32 位的中断返回操作。
 - **`iretq`**
    - **适用架构**：用于 64 位 x86 - 64 架构。
    - **操作数大小**：`iretq` 会弹出 16 个字节的数据，包含 8 字节的 `RIP`（64 位指令指针）、8 字节的 `CS` 和 8 字节的 `RFLAGS`（64 位标志寄存器）。这是为了适应 64 位系统更大的地址空间和寄存器宽度。

### 2. 指令功能与使用场景
- **功能**
    - 这三条指令的核心功能都是从当前的中断或异常处理程序中返回，恢复被中断程序的执行环境。它们会按照特定的顺序从栈中弹出相应的寄存器值，然后将控制权交还给被中断的程序。
 - **使用场景**
    - **`iret`**：当编写的代码需要同时兼容 16 位和 32 位系统时，使用 `iret` 是一个合适的选择。例如，在一些早期的操作系统开发或者跨平台的中断处理代码中会用到。
    - **`iretd`**：在 32 位系统的开发中，如果需要明确表示是 32 位的中断返回操作，使用 `iretd` 可以提高代码的可读性。比如在 32 位 Linux 内核的中断处理代码中就可能会使用到。
    - **`iretq`**：在 64 位系统的开发中，必须使用 `iretq` 来进行中断返回操作，以确保能够正确恢复 64 位的执行环境。例如，64 位 Windows 或 Linux 内核的中断处理程序就会使用 `iretq`。

### 3. 示例代码片段（伪代码）
#### 16 位模式下的 `iret`
```asm
; 假设中断处理程序结束，准备返回
iret ; 弹出 IP、CS 和 FLAGS 恢复执行环境
```

#### 32 位模式下的 `iretd`
```asm
; 32 位中断处理程序结束
iretd ; 弹出 EIP、CS 和 EFLAGS 恢复执行环境
```

#### 64 位模式下的 `iretq`
```asm
; 64 位中断处理程序结束
iretq ; 弹出 RIP、CS 和 RFLAGS 恢复执行环境
```

综上所述，`iret`、`iretd` 和 `iretq` 的主要区别在于适用的架构和操作数大小，你需要根据具体的系统架构来选择合适的指令。 

