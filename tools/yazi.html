<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Yazi Pro ‚Ä¢ Fixed Layout Vim Editor</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/monokai.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Fira Code', 'Cascadia Code', monospace;
      background: #1e1e1e;
      color: #d4d4d4;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #header {
      padding: 6px 12px;
      background: #252526;
      border-bottom: 1px solid #3c3c3c;
      font-size: 13px;
      color: #9cdcfe;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #list {
      flex: 1;
      padding: 8px;
      overflow-y: auto;
      background: #1e1e1e;
      font-size: 13px;
    }
    #preview {
      width: 50%;
      padding: 12px;
      background: #1e1e1e;
      border-left: 1px solid #3c3c3c;
      overflow: auto;
    }
    .item {
      padding: 4px 0;
      display: flex;
      justify-content: space-between;
    }
    .item.selected {
      background: #264f78;
      color: white;
    }
    .folder { color: #d7ba7d; }
    .file { color: #9cdcfe; }
    .size { color: #888; margin-left: 12px; }
    #status {
      padding: 4px 12px;
      background: #000;
      border-top: 1px solid #333;
      font-size: 12px;
      color: #aaa;
      display: flex;
      justify-content: space-between;
    }
    #help {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.92);
      color: #ccc;
      padding: 8px 12px;
      font-size: 11px;
      z-index: 9;
      border-top: 1px solid #333;
      max-height: 120px;
      overflow-y: auto;
    }
    .key-group {
      display: inline-block;
      margin-right: 20px;
      vertical-align: top;
    }
    .key-item { white-space: nowrap; margin: 2px 0; }
    kbd {
      background: #333;
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 10px;
      border: 1px solid #555;
    }
    #editor-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1e1e1e;
      z-index: 100;
      display: none;
      flex-direction: column;
    }
    #editor-header {
      flex: 0 0 auto;
      padding: 8px 12px;
      background: #252526;
      border-bottom: 1px solid #3c3c3c;
      font-size: 13px;
      color: #ce9178;
      display: flex;
      justify-content: space-between;
    }
    #editor-container {
      flex: 1;
      padding: 12px;
      overflow: hidden;
    }
    .CodeMirror {
      height: 100%;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
    }
    #editor-help {
      flex: 0 0 90px;
      background: rgba(0, 0, 0, 0.92);
      color: #ccc;
      padding: 8px 12px;
      font-size: 11px;
      border-top: 1px solid #333;
      overflow-y: auto;
    }
    .vim-key-group {
      display: inline-block;
      margin-right: 15px;
      vertical-align: top;
    }
    .binary-message { color: #ff6666; font-style: italic; }
    #preview img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
      background: #333;
      padding: 8px;
    }
    #preview embed {
      width: 100%;
      height: 100%;
      min-height: 500px;
      border: none;
    }
    #preview pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div id="header">yazi-pro ‚Ä¢ No folder opened</div>
  <div id="main">
    <div id="list"></div>
    <div id="preview">Select a file to preview</div>
  </div>
  <div id="status">No folder ‚Ä¢ Press o to open</div>
  
  <!-- Main file manager help -->
  <div id="help">
    <div class="key-group">
      <div class="key-item"><kbd>j</kbd>/<kbd>k</kbd> ‚Äì Nav ‚Ä¢ <kbd>h</kbd> ‚Äì Up ‚Ä¢ <kbd>l</kbd> ‚Äì Open</div>
      <div class="key-item"><kbd>i</kbd> ‚Äì Edit (Vim) ‚Ä¢ <kbd>r</kbd> ‚Äì Rename ‚Ä¢ <kbd>x</kbd> ‚Äì Delete</div>
    </div>
    <div class="key-group">
      <div class="key-item"><kbd>yy</kbd> ‚Äì Copy ‚Ä¢ <kbd>dd</kbd> ‚Äì Cut ‚Ä¢ <kbd>p</kbd> ‚Äì Paste</div>
      <div class="key-item"><kbd>/</kbd> ‚Äì Search ‚Ä¢ <kbd>u</kbd> ‚Äì Undo ‚Ä¢ <kbd>H</kbd> ‚Äì Re-root</div>
    </div>
    <div class="key-group">
      <div class="key-item"><kbd>o</kbd> ‚Äì Open folder ‚Ä¢ <kbd>q</kbd> ‚Äì Quit</div>
    </div>
  </div>

  <!-- Vim Editor Overlay (with help inside) -->
  <div id="editor-overlay">
    <div id="editor-header">
      <span id="editor-title">‚Äî VIM ‚Äî</span>
      <span id="editor-status">NORMAL</span>
    </div>
    <div id="editor-container">
      <textarea id="code-editor"></textarea>
    </div>
    <div id="editor-help">
      <div class="vim-key-group">
        <div class="key-item"><kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd> ‚Äì ‚Üê ‚Üì ‚Üë ‚Üí</div>
        <div class="key-item"><kbd>w</kbd>/<kbd>b</kbd> ‚Äì Word next/prev</div>
        <div class="key-item"><kbd>0</kbd> / <kbd>^</kbd> / <kbd>$</kbd> ‚Äì BOL / Indent / EOL</div>
      </div>
      <div class="vim-key-group">
        <div class="key-item"><kbd>i</kbd>/<kbd>a</kbd> ‚Äì Insert before/after</div>
        <div class="key-item"><kbd>x</kbd> ‚Äì Delete char</div>
        <div class="key-item"><kbd>dd</kbd> ‚Äì Delete line</div>
        <div class="key-item"><kbd>yy</kbd> ‚Äì Yank line</div>
        <div class="key-item"><kbd>p</kbd> ‚Äì Paste after</div>
      </div>
      <div class="vim-key-group">
        <div class="key-item"><kbd>u</kbd> ‚Äì Undo</div>
        <div class="key-item"><kbd>Ctrl</kbd>+<kbd>r</kbd> ‚Äì Redo</div>
        <div class="key-item"><kbd>/pattern</kbd> ‚Äì Search</div>
        <div class="key-item"><kbd>n</kbd> / <kbd>N</kbd> ‚Äì Next / Prev match</div>
      </div>
      <div class="vim-key-group">
        <div class="key-item"><kbd>:</kbd><kbd>w</kbd> ‚Äì Save</div>
        <div class="key-item"><kbd>:</kbd><kbd>q</kbd> ‚Äì Quit</div>
        <div class="key-item"><kbd>:</kbd><kbd>wq</kbd> ‚Äì Save & quit</div>
        <div class="key-item"><kbd>Esc</kbd> ‚Äì Normal mode</div>
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/keymap/vim.min.js"></script>

  <script>
    // === State ===
    let rootDirHandle = null;
    let virtualPath = [];
    let currentDirHandle = null;
    let currentFileHandle = null;
    let currentFileName = '';
    let entries = [];
    let selectedIndex = -1;
    let clipboardItem = null;
    let clipboardRootPath = [];
    let editor = null;
    let isEditing = false;

    const header = document.getElementById('header');
    const listEl = document.getElementById('list');
    const previewEl = document.getElementById('preview');
    const statusEl = document.getElementById('status');
    const editorOverlay = document.getElementById('editor-overlay');
    const editorTitle = document.getElementById('editor-title');
    const editorStatus = document.getElementById('editor-status');
    const codeEditor = document.getElementById('code-editor');

    // === File helpers ===
    const CODE_EXTENSIONS = new Set(['.js','.ts','.jsx','.tsx','.py','.java','.cpp','.c','.h','.cs','.html','.htm','.xml','.css','.scss','.sass','.less','.json','.yaml','.yml','.toml','.ini','.sh','.bash','.md','.markdown','.txt','.log']);
    const IMAGE_EXTENSIONS = new Set(['.png','.jpg','.jpeg','.gif','.bmp','.webp','.svg']);

    function getExtension(filename) {
      return filename.includes('.') ? filename.slice(filename.lastIndexOf('.')).toLowerCase() : '';
    }

    function getFileType(filename) {
      const ext = getExtension(filename);
      if (CODE_EXTENSIONS.has(ext)) return 'code';
      if (IMAGE_EXTENSIONS.has(ext)) return 'image';
      if (ext === '.pdf') return 'pdf';
      if (ext === '.txt' || ext === '.md' || ext === '.log') return 'text';
      return 'binary';
    }

    function getPrismLanguageClass(filename) {
      const ext = getExtension(filename);
      const map = {
        '.js': 'javascript', '.ts': 'typescript', '.jsx': 'jsx', '.tsx': 'tsx',
        '.py': 'python', '.java': 'java', '.cpp': 'cpp', '.c': 'c', '.cs': 'csharp',
        '.html': 'html', '.css': 'css', '.json': 'json', '.md': 'markdown',
        '.sh': 'bash', '.yaml': 'yaml', '.yml': 'yaml', '.xml': 'xml'
      };
      return map[ext] || 'plaintext';
    }

    function getMode(filename) {
      const ext = getExtension(filename);
      if (ext === '.js' || ext === '.ts' || ext === '.jsx' || ext === '.tsx') return 'javascript';
      if (ext === '.py') return 'python';
      if (ext === '.java' || ext === '.cpp' || ext === '.c' || ext === '.cs') return 'text/x-c++src';
      if (ext === '.html') return 'htmlmixed';
      if (ext === '.css') return 'css';
      if (ext === '.json') return 'application/json';
      if (ext === '.md') return 'markdown';
      if (ext === '.sh' || ext === '.bash') return 'shell';
      if (ext === '.yaml' || ext === '.yml') return 'yaml';
      return 'text/plain';
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    // === Vim Editor ===
    function initVimEditor(content = '', filename = '') {
      if (editor) {
        editor.toTextArea();
      }
      codeEditor.value = content;
      editor = CodeMirror.fromTextArea(codeEditor, {
        mode: getMode(filename),
        keyMap: "vim",
        theme: "monokai",
        lineNumbers: true,
        lineWrapping: true,
        autofocus: false,
        viewportMargin: Infinity
      });

      editor.on('vim-mode-change', (e) => {
        let mode = e.mode;
        if (mode === 'insert') mode = 'INSERT';
        else if (mode === 'normal') mode = 'NORMAL';
        else if (mode === 'visual') mode = 'VISUAL';
        editorStatus.textContent = mode;
      });

      CodeMirror.Vim.defineEx('write', 'w', async () => {
        await saveCurrentFile();
      });
      CodeMirror.Vim.defineEx('quit', 'q', () => {
        closeEditor();
      });
      CodeMirror.Vim.defineEx('wq', 'wq', async () => {
        await saveCurrentFile();
        closeEditor();
      });
    }

    async function saveCurrentFile() {
      if (!currentFileHandle) return;
      try {
        const content = editor.getValue();
        const writable = await currentFileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        statusEl.textContent = '‚úÖ Saved';
      } catch (err) {
        alert('Save failed: ' + err.message);
      }
    }

    function closeEditor() {
      if (isEditing) {
        editorOverlay.style.display = 'none';
        isEditing = false;
        refreshView();
      }
    }

    async function enterEditMode() {
      const entry = entries[selectedIndex];
      if (!entry || entry.kind !== 'file') return;
      const ft = getFileType(entry.name);
      if (ft !== 'code' && ft !== 'text') {
        statusEl.textContent = '‚ö†Ô∏è Only text/code files editable';
        return;
      }

      try {
        const file = await entry.handle.getFile();
        const text = await file.text();
        currentFileHandle = entry.handle;
        currentFileName = entry.name;
        editorTitle.textContent = `‚Äî VIM ‚Äî ${entry.name}`;
        
        initVimEditor(text, entry.name);
        editorOverlay.style.display = 'flex'; // shows all: header + editor + help
        
        void editorOverlay.offsetWidth;
        editor.refresh();
        editor.focus();
        editor.setCursor({ line: 0, ch: 0 });
        editor.scrollIntoView({ line: 0, ch: 0 }, 100);
        isEditing = true;
      } catch (err) {
        alert('Load failed: ' + err.message);
      }
    }

    // === Rest of app (abbreviated for space ‚Äî same as before) ===
    async function resolveDirHandleFromPath(path) {
      let h = rootDirHandle;
      for (const seg of path) h = await h.getDirectoryHandle(seg);
      return h;
    }

    async function refreshCurrentDir() {
      if (!rootDirHandle) return;
      try {
        currentDirHandle = await resolveDirHandleFromPath(virtualPath);
      } catch (e) {
        virtualPath = [];
        currentDirHandle = rootDirHandle;
      }
    }

    async function refreshView() {
      if (!rootDirHandle) {
        header.textContent = 'yazi-pro ‚Ä¢ No folder opened';
        listEl.innerHTML = '';
        previewEl.innerHTML = 'Press "o" to open a folder';
        statusEl.textContent = 'No folder ‚Ä¢ Press o to open';
        return;
      }

      await refreshCurrentDir();
      const path = virtualPath.length ? `/${virtualPath.join('/')}` : '/';
      header.textContent = `yazi-pro ‚Ä¢ üìÅ ${path}`;

      entries = [];
      for await (const [name, handle] of currentDirHandle.entries()) {
        let size = '-';
        if (handle.kind === 'file') {
          const f = await handle.getFile();
          size = formatBytes(f.size);
        }
        entries.push({ name, handle, kind: handle.kind, size });
      }

      entries.sort((a, b) => (a.kind !== b.kind) ? (a.kind === 'directory' ? -1 : 1) : a.name.localeCompare(b.name));

      renderList();
      selectIndex(0);
    }

    function renderList(filter = null) {
      listEl.innerHTML = '';
      const filtered = filter ? entries.filter(e => e.name.toLowerCase().includes(filter.toLowerCase())) : entries;
      filtered.forEach((entry, i) => {
        const el = document.createElement('div');
        el.className = `item ${entry.kind} ${i === selectedIndex ? 'selected' : ''}`;
        const name = document.createElement('span');
        name.textContent = `${entry.kind === 'directory' ? 'üìÅ ' : 'üìÑ '}${entry.name}`;
        const size = document.createElement('span');
        size.className = 'size';
        size.textContent = entry.size;
        el.appendChild(name);
        el.appendChild(size);
        el.onclick = () => selectAndOpen(i, filtered);
        listEl.appendChild(el);
      });
      statusEl.textContent = rootDirHandle 
        ? `Items: ${filtered.length} ‚Ä¢ Cursor: ${selectedIndex + 1}/${filtered.length}`
        : 'No folder ‚Ä¢ Press o to open';
    }

    function selectIndex(index, filtered = entries) {
      if (filtered.length === 0) return;
      selectedIndex = Math.max(0, Math.min(filtered.length - 1, index));
      renderList();
      previewFile(filtered[selectedIndex]);
    }

    async function previewFile(entry) {
      if (!entry || entry.kind !== 'file') {
        previewEl.innerHTML = entry?.kind === 'directory' ? 'üìÅ Directory' : 'No file selected';
        return;
      }
      const ft = getFileType(entry.name);
      try {
        const file = await entry.handle.getFile();
        if (ft === 'image') {
          const url = URL.createObjectURL(file);
          previewEl.innerHTML = `<img src="${url}" alt="${entry.name}" onload="URL.revokeObjectURL('${url}')">`;
        } else if (ft === 'pdf') {
          const url = URL.createObjectURL(file);
          previewEl.innerHTML = `<embed src="${url}" type="application/pdf" />`;
        } else if (ft === 'code' || ft === 'text') {
          const text = await file.text();
          const langClass = getPrismLanguageClass(entry.name);
          previewEl.innerHTML = `<pre><code class="language-${langClass}">${Prism.util.encode(text)}</code></pre>`;
          setTimeout(() => Prism.highlightAllUnder(previewEl), 0);
        } else {
          previewEl.innerHTML = `<div class="binary-message">‚ö†Ô∏è Binary file</div>`;
        }
      } catch (e) {
        previewEl.innerHTML = `<div class="binary-message">‚ùå Read error</div>`;
      }
    }

    async function selectAndOpen(index, filtered = entries) {
      const entry = filtered[index];
      if (entry.kind === 'directory') {
        virtualPath.push(entry.name);
        refreshView();
      } else {
        selectedIndex = index;
        renderList();
        previewFile(entry);
      }
    }

    async function deleteEntry() {
      if (selectedIndex < 0) return;
      const entry = entries[selectedIndex];
      if (!confirm(`Delete "${entry.name}"?`)) return;
      try {
        if (entry.kind === 'file') {
          await currentDirHandle.removeEntry(entry.name);
        } else {
          await currentDirHandle.removeEntry(entry.name, { recursive: true });
        }
        refreshView();
      } catch (e) {
        alert('Delete failed: ' + e.message);
      }
    }

    async function openFolder() {
      try {
        rootDirHandle = await window.showDirectoryPicker();
        virtualPath = []; selectedIndex = -1;
        refreshView();
      } catch (e) {
        if (e.name !== 'AbortError') console.error(e);
      }
    }

    document.body.addEventListener('keydown', async (e) => {
      if (isEditing) return;
      if (!rootDirHandle && !['o','q'].includes(e.key)) return;

      if (e.key === 'j' && entries.length) { e.preventDefault(); selectIndex(selectedIndex + 1); }
      else if (e.key === 'k' && entries.length) { e.preventDefault(); selectIndex(selectedIndex - 1); }
      else if ((e.key === 'l' || e.key === 'Enter') && entries[selectedIndex]) {
        e.preventDefault(); await selectAndOpen(selectedIndex);
      }
      else if (e.key === 'h' && virtualPath.length > 0) { e.preventDefault(); virtualPath.pop(); refreshView(); }
      else if (e.key === 'o') { e.preventDefault(); await openFolder(); }
      else if (e.key === 'q') { e.preventDefault(); rootDirHandle = null; refreshView(); }
      else if (e.key === 'i' && entries[selectedIndex]?.kind === 'file') {
        e.preventDefault();
        const ft = getFileType(entries[selectedIndex].name);
        if (ft === 'code' || ft === 'text') enterEditMode();
      }
      else if (e.key === 'x') { e.preventDefault(); deleteEntry(); }
    });

    refreshView();
  </script>
</body>
</html>