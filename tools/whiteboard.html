<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ç™½æ¿åº”ç”¨</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: #f9fafb;
      color: #1f2937;
      overflow-x: hidden;
    }
    #toolbar {
      background: white;
      padding: 16px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: center;
    }
    .tool-group {
      display: flex;
      gap: 8px;
    }
    .tool-btn {
      padding: 9px 16px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.15s ease;
      color: #374151;
    }
    .tool-btn:hover {
      background-color: #f3f4f6;
      border-color: #9ca3af;
    }
    .tool-btn.active {
      background: #2563eb;
      color: white;
      border-color: #2563eb;
    }
    .control-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .control-label {
      font-size: 13px;
      color: #4b5563;
      font-weight: 500;
    }
    .color-input {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .line-width-input {
      width: 100px;
    }
    .font-size-input {
      width: 70px;
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }
    #clear-btn {
      margin-left: auto;
      padding: 9px 20px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: background 0.2s;
    }
    #clear-btn:hover {
      background: #dc2626;
    }
    #number-reset-btn {
      padding: 9px 16px;
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: background 0.2s;
    }
    #number-reset-btn:hover {
      background: #d97706;
    }
    #canvas-container {
      position: relative;
      margin: 20px auto;
      max-width: 1400px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      width: 100%;
    }
    canvas {
      display: block;
      background: white;
    }
    #main-canvas {
      cursor: crosshair;
    }
    .instructions {
      text-align: center;
      margin-top: 12px;
      color: #6b7280;
      font-size: 13px;
    }
    /* Text box styles */
    .text-box {
      position: absolute;
      border: 2px solid #3b82f6;
      background: white;
      z-index: 100;
      min-width: 50px;
      min-height: 20px;
    }
    .text-box-content {
      border: none;
      outline: none;
      width: 100%;
      height: 100%;
      resize: none;
      font-family: Arial, sans-serif;
      padding: 4px;
      background: transparent;
    }
    /* Image overlay styles */
    .image-overlay {
      position: absolute;
      border: 2px solid #3b82f6;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      cursor: move;
    }
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: se-resize;
    }
    .resize-handle-se {
      bottom: -6px;
      right: -6px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-group">
      <button class="tool-btn active" data-tool="pen">âœï¸ ç”»ç¬”</button>
      <button class="tool-btn" data-tool="rect">â¬œ çŸ©å½¢</button>
      <button class="tool-btn" data-tool="circle">â­• åœ†å½¢</button>
      <button class="tool-btn" data-tool="line">ğŸ“ ç›´çº¿</button>
      <button class="tool-btn" data-tool="arrow">â¡ï¸ ç®­å¤´</button>
      <button class="tool-btn" data-tool="number">ğŸ”¢ æ•°å­—</button>
      <button class="tool-btn" data-tool="text">ğŸ”¤ æ–‡æœ¬</button>
    </div>

    <div class="control-item">
      <span class="control-label">è¾¹æ¡†</span>
      <input type="color" id="strokeColor" class="color-input" value="#000000">
    </div>
    <div class="control-item">
      <span class="control-label">å¡«å……</span>
      <input type="color" id="fillColor" class="color-input" value="#ffffff">
    </div>
    <div class="control-item">
      <span class="control-label">çº¿å®½</span>
      <input type="range" id="lineWidth" class="line-width-input" min="1" max="20" value="2">
    </div>
    <div class="control-item">
      <span class="control-label">å­—ä½“</span>
      <input type="number" id="fontSize" class="font-size-input" min="8" max="72" value="16">
    </div>

    <button id="undo-btn" class="tool-btn">â†©ï¸ æ’¤é”€</button>
    <button id="redo-btn" class="tool-btn">â†ªï¸ é‡åš</button>
    <button id="number-reset-btn" style="display: none;">ğŸ”„ é‡ç½®æ•°å­—</button>
    <button id="paste-btn" class="tool-btn">ğŸ“‹ ç²˜è´´</button>
    <button id="clear-btn">ğŸ—‘ï¸ æ¸…ç©º</button>
  </div>

  <div id="canvas-container">
    <canvas id="main-canvas"></canvas>
  </div>

  <div class="instructions">
    æç¤ºï¼šç»˜åˆ¶å›¾å½¢æ—¶æ‹–åŠ¨é¼ æ ‡é¢„è§ˆæ•ˆæœï¼Œé‡Šæ”¾å®Œæˆç»˜åˆ¶
  </div>

  <script>
    // åˆå§‹åŒ–ç”»å¸ƒ
    const canvasContainer = document.getElementById('canvas-container');
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    // è®¾ç½®åˆå§‹å°ºå¯¸
    function setCanvasSize() {
      const maxWidth = Math.min(canvasContainer.clientWidth, 1400);
      const maxHeight = Math.min(window.innerHeight - 250, 800);
      
      canvas.width = maxWidth;
      canvas.height = maxHeight;
    }
    
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);

    // é»˜è®¤è®¾ç½®
    let tool = 'pen';
    let isDrawing = false;
    let startX, startY;
    let strokeColor = '#000000';
    let fillColor = '#ffffff';
    let lineWidth = 2;
    let fontSize = 16;
    let lastX = 0;
    lastY = 0;
    let savedState = null;
    let history = [];
    let historyIndex = -1;
    let numberCounter = 1;

    // å·¥å…·é»˜è®¤è®¾ç½®
    const toolSettings = {
      pen: { strokeColor: '#000000', fillColor: '#ffffff', lineWidth: 2, fontSize: 16 },
      rect: { strokeColor: '#000000', fillColor: '#ffffff', lineWidth: 2, fontSize: 16 },
      circle: { strokeColor: '#000000', fillColor: '#ffffff', lineWidth: 2, fontSize: 16 },
      line: { strokeColor: '#000000', fillColor: '#ffffff', lineWidth: 2, fontSize: 16 },
      arrow: { strokeColor: '#ef4444', fillColor: '#ef4444', lineWidth: 3, fontSize: 16 },
      number: { strokeColor: '#ef4444', fillColor: '#ef4444', lineWidth: 2, fontSize: 16 },
      text: { strokeColor: '#000000', fillColor: '#ffffff', lineWidth: 2, fontSize: 16 }
    };

    // åˆå§‹åŒ–ç”»å¸ƒ
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // æ›´æ–°ç”»ç¬”å…‰æ ‡
    function updateCursor() {
      if (tool === 'pen') {
        canvas.style.cursor = 'crosshair';
      } else if (tool === 'text') {
        canvas.style.cursor = 'text';
      } else {
        canvas.style.cursor = 'crosshair';
      }
    }

    // å·¥å…·æŒ‰é’®äº‹ä»¶
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        tool = btn.dataset.tool;
        updateCursor();
        
        // å–æ¶ˆå½“å‰ç»˜åˆ¶
        if (isDrawing && tool !== 'text') {
          isDrawing = false;
          savedState = null;
        }
        
        // åº”ç”¨å½“å‰å·¥å…·çš„é»˜è®¤è®¾ç½®
        if (toolSettings[tool]) {
          strokeColor = toolSettings[tool].strokeColor;
          fillColor = toolSettings[tool].fillColor;
          lineWidth = toolSettings[tool].lineWidth;
          fontSize = toolSettings[tool].fontSize;
        }
        
        // æ›´æ–°UI
        document.getElementById('strokeColor').value = strokeColor;
        document.getElementById('fillColor').value = fillColor;
        document.getElementById('lineWidth').value = lineWidth;
        document.getElementById('fontSize').value = fontSize;
        
        // æ˜¾ç¤º/éšè—æ•°å­—é‡ç½®æŒ‰é’®
        const numberResetBtn = document.getElementById('number-reset-btn');
        if (tool === 'number') {
          numberResetBtn.style.display = 'inline-block';
        } else {
          numberResetBtn.style.display = 'none';
        }
      });
    });

    // æ§ä»¶äº‹ä»¶
    document.getElementById('strokeColor').addEventListener('input', e => strokeColor = e.target.value);
    document.getElementById('fillColor').addEventListener('input', e => fillColor = e.target.value);
    document.getElementById('lineWidth').addEventListener('input', e => lineWidth = e.target.value);
    document.getElementById('fontSize').addEventListener('input', e => {
      fontSize = e.target.value;
      // æ›´æ–°å½“å‰æ‰€æœ‰æ–‡æœ¬æ¡†çš„å­—ä½“å¤§å°
      document.querySelectorAll('.text-box-content').forEach(textbox => {
        textbox.style.fontSize = fontSize + 'px';
      });
    });
    document.getElementById('clear-btn').addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // ç§»é™¤æ‰€æœ‰æ–‡æœ¬æ¡†
      document.querySelectorAll('.text-box').forEach(el => el.remove());
      // ç§»é™¤æ‰€æœ‰å›¾ç‰‡
      document.querySelectorAll('.image-overlay').forEach(el => el.remove());
      saveStateToHistory();
    });

    // æ•°å­—é‡ç½®æŒ‰é’®äº‹ä»¶
    document.getElementById('number-reset-btn').addEventListener('click', () => {
      numberCounter = 1;
      alert('æ•°å­—å·²é‡ç½®ä¸º 1');
    });

    // ç²˜è´´æŒ‰é’®äº‹ä»¶
    document.getElementById('paste-btn').addEventListener('click', () => {
      // æç¤ºç”¨æˆ·ç²˜è´´å†…å®¹
      alert('è¯·åœ¨ç”»å¸ƒä¸Šå³é”®ç²˜è´´æˆ–ä½¿ç”¨ Ctrl+V ç²˜è´´å†…å®¹');
    });

    // æ’¤é”€é‡åšåŠŸèƒ½
    document.getElementById('undo-btn').addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        restoreStateFromHistory();
      }
    });

    document.getElementById('redo-btn').addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreStateFromHistory();
      }
    });

    function saveStateToHistory() {
      // ä¿å­˜å½“å‰ç”»å¸ƒçŠ¶æ€
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      history = history.slice(0, historyIndex + 1);
      history.push(imageData);
      historyIndex++;
    }

    function restoreStateFromHistory() {
      if (historyIndex >= 0 && historyIndex < history.length) {
        ctx.putImageData(history[historyIndex], 0, 0);
      }
    }

    // é¼ æ ‡äº‹ä»¶å¤„ç†
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', cancelDrawing);

    // ç²˜è´´äº‹ä»¶å¤„ç†
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData.items;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        
        if (item.type.indexOf('image') !== -1) {
          // å¤„ç†å›¾ç‰‡ç²˜è´´
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
              // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
              const imgElement = document.createElement('img');
              imgElement.src = event.target.result;
              imgElement.style.width = '100%';
              imgElement.style.height = '100%';
              imgElement.style.objectFit = 'contain';
              
              // åˆ›å»ºå®¹å™¨
              const container = document.createElement('div');
              container.className = 'image-overlay';
              container.style.left = '50px';
              container.style.top = '50px';
              container.style.width = Math.min(img.width, 200) + 'px';
              container.style.height = Math.min(img.height, 200) + 'px';
              
              // æ·»åŠ å›¾ç‰‡
              container.appendChild(imgElement);
              
              // æ·»åŠ è°ƒæ•´å¤§å°çš„å¥æŸ„
              const handle = document.createElement('div');
              handle.className = 'resize-handle resize-handle-se';
              container.appendChild(handle);
              
              // æ·»åŠ åˆ°ç”»å¸ƒå®¹å™¨
              canvasContainer.appendChild(container);
              
              // å®ç°æ‹–æ‹½å’Œè°ƒæ•´å¤§å°åŠŸèƒ½
              let isDragging = false;
              let isResizing = false;
              let offsetX, offsetY;
              
              container.addEventListener('mousedown', (e) => {
                if (e.target === handle) {
                  isResizing = true;
                  e.preventDefault();
                } else {
                  isDragging = true;
                  const containerRect = container.getBoundingClientRect();
                  offsetX = e.clientX - containerRect.left;
                  offsetY = e.clientY - containerRect.top;
                  e.preventDefault();
                }
              });
              
              document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                  const containerRect = canvasContainer.getBoundingClientRect();
                  let x = e.clientX - containerRect.left - offsetX;
                  let y = e.clientY - containerRect.top - offsetY;
                  
                  // é™åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…
                  x = Math.max(0, Math.min(x, canvasContainer.clientWidth - container.offsetWidth));
                  y = Math.max(0, Math.min(y, canvasContainer.clientHeight - container.offsetHeight));
                  
                  container.style.left = x + 'px';
                  container.style.top = y + 'px';
                } else if (isResizing) {
                  const containerRect = container.getBoundingClientRect();
                  const newWidth = e.clientX - containerRect.left;
                  const newHeight = e.clientY - containerRect.top;
                  
                  if (newWidth > 20 && newHeight > 20) {
                    container.style.width = newWidth + 'px';
                    container.style.height = newHeight + 'px';
                  }
                }
              });
              
              document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
              });
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(blob);
        } else if (item.type === 'text/plain') {
          // å¤„ç†æ–‡æœ¬ç²˜è´´
          item.getAsString(function(str) {
            createTextBox(50, 50, str);
          });
        }
      }
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function startDrawing(e) {
      if (tool === 'text') {
        const pos = getMousePos(e);
        createTextBox(pos.x, pos.y);
        return;
      }
      
      isDrawing = true;
      const pos = getMousePos(e);
      startX = pos.x;
      startY = pos.y;
      lastX = pos.x;
      lastY = pos.y;

      if (tool !== 'pen' && tool !== 'text') {
        // ä¿å­˜å½“å‰ç”»å¸ƒçŠ¶æ€
        savedState = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }
    }

    function draw(e) {
      if (!isDrawing || tool === 'text') return;

      const pos = getMousePos(e);
      const currentX = pos.x;
      const currentY = pos.y;

      if (tool === 'pen') {
        // ç›´æ¥ç»˜åˆ¶åˆ°ä¸»ç”»å¸ƒ
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();
        lastX = currentX;
        lastY = currentY;
      } else if (tool === 'arrow') {
        // æ¢å¤ä¿å­˜çš„çŠ¶æ€
        if (savedState) {
          ctx.putImageData(savedState, 0, 0);
        }
        
        // è®¾ç½®æ ·å¼
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = strokeColor; // ç®­å¤´å¡«å……é¢œè‰²
        ctx.lineWidth = lineWidth;
        
        // ç»˜åˆ¶ç›´çº¿
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();
        
        // è®¡ç®—ç®­å¤´æ–¹å‘
        const angle = Math.atan2(currentY - startY, currentX - startX);
        const arrowSize = 10 + lineWidth; // ç®­å¤´å¤§å°éšçº¿å®½å˜åŒ–
        
        // ç»˜åˆ¶ç®­å¤´
        ctx.beginPath();
        ctx.moveTo(currentX, currentY);
        ctx.lineTo(
          currentX - arrowSize * Math.cos(angle - Math.PI / 6),
          currentY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          currentX - arrowSize * Math.cos(angle + Math.PI / 6),
          currentY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
      } else if (tool === 'number') {
        // æ¢å¤ä¿å­˜çš„çŠ¶æ€
        if (savedState) {
          ctx.putImageData(savedState, 0, 0);
        }
        
        // è®¾ç½®æ ·å¼
        ctx.strokeStyle = '#ef4444'; // çº¢è‰²è¾¹æ¡†
        ctx.fillStyle = '#ef4444'; // çº¢è‰²å¡«å……
        ctx.lineWidth = 2;
        
        // ç»˜åˆ¶åœ†åœˆ
        const radius = 15;
        ctx.beginPath();
        ctx.arc(currentX, currentY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶æ•°å­—
        ctx.fillStyle = '#ffffff'; // ç™½è‰²æ–‡å­—
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(numberCounter.toString(), currentX, currentY);
      } else {
        // æ¢å¤ä¿å­˜çš„çŠ¶æ€
        if (savedState) {
          ctx.putImageData(savedState, 0, 0);
        }
        
        // è®¾ç½®æ ·å¼
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = fillColor;
        ctx.lineWidth = lineWidth;
        
        if (tool === 'rect') {
          const w = currentX - startX;
          const h = currentY - startY;
          
          // å¤„ç†è´Ÿå®½é«˜
          const x = w < 0 ? currentX : startX;
          const y = h < 0 ? currentY : startY;
          const width = Math.abs(w);
          const height = Math.abs(h);
          
          // å…ˆå¡«å……å†æè¾¹ï¼Œç¡®ä¿è¾¹æ¡†å¯è§
          if (fillColor !== 'transparent') {
            ctx.fillRect(x, y, width, height);
          }
          ctx.strokeRect(x, y, width, height);
        } else if (tool === 'circle') {
          // ä½¿ç”¨èµ·å§‹ç‚¹å’Œç»“æŸç‚¹ä½œä¸ºç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹
          const centerX = (startX + currentX) / 2;
          const centerY = (startY + currentY) / 2;
          const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2)) / 2;
          
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          
          if (fillColor !== 'transparent') {
            ctx.fill();
          }
          ctx.stroke();
        } else if (tool === 'line') {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(currentX, currentY);
          ctx.stroke();
        }
      }
    }

    function stopDrawing(e) {
      if (tool === 'text' || !isDrawing) return;
      
      const pos = getMousePos(e);
      const endX = pos.x;
      const endY = pos.y;

      // æ¢å¤ä¿å­˜çš„çŠ¶æ€
      if (savedState) {
        ctx.putImageData(savedState, 0, 0);
      }
      
      ctx.strokeStyle = strokeColor;
      ctx.fillStyle = strokeColor; // ç®­å¤´å¡«å……é¢œè‰²
      ctx.lineWidth = lineWidth;
      
      if (tool === 'rect') {
        const w = endX - startX;
        const h = endY - startY;
        
        // å¤„ç†è´Ÿå®½é«˜
        const x = w < 0 ? endX : startX;
        const y = h < 0 ? endY : startY;
        const width = Math.abs(w);
        const height = Math.abs(h);
        
        if (fillColor !== 'transparent') {
          ctx.fillRect(x, y, width, height);
        }
        ctx.strokeRect(x, y, width, height);
      } else if (tool === 'circle') {
        // ä½¿ç”¨èµ·å§‹ç‚¹å’Œç»“æŸç‚¹ä½œä¸ºç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹
        const centerX = (startX + endX) / 2;
        const centerY = (startY + endY) / 2;
        const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) / 2;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        
        if (fillColor !== 'transparent') {
          ctx.fill();
        }
        ctx.stroke();
      } else if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      } else if (tool === 'arrow') {
        // ç»˜åˆ¶æœ€ç»ˆç®­å¤´
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // è®¡ç®—ç®­å¤´æ–¹å‘
        const angle = Math.atan2(endY - startY, endX - startX);
        const arrowSize = 10 + lineWidth; // ç®­å¤´å¤§å°éšçº¿å®½å˜åŒ–
        
        // ç»˜åˆ¶ç®­å¤´
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
      } else if (tool === 'number') {
        // ç»˜åˆ¶æ•°å­—åœˆ
        ctx.strokeStyle = '#ef4444'; // çº¢è‰²è¾¹æ¡†
        ctx.fillStyle = '#ef4444'; // çº¢è‰²å¡«å……
        ctx.lineWidth = 2;
        
        // ç»˜åˆ¶åœ†åœˆ
        const radius = 15;
        ctx.beginPath();
        ctx.arc(endX, endY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶æ•°å­—
        ctx.fillStyle = '#ffffff'; // ç™½è‰²æ–‡å­—
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(numberCounter.toString(), endX, endY);
        
        // å¢åŠ æ•°å­—è®¡æ•°
        numberCounter++;
      }
      
      savedState = null;
      isDrawing = false;
      
      // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
      saveStateToHistory();
    }

    function cancelDrawing() {
      if (isDrawing && tool !== 'text') {
        // æ¢å¤ä¿å­˜çš„çŠ¶æ€
        if (savedState) {
          ctx.putImageData(savedState, 0, 0);
        }
        savedState = null;
      }
      isDrawing = false;
    }

    // åˆ›å»ºæ–‡æœ¬æ¡†
    function createTextBox(x, y, initialText = '') {
      const textBox = document.createElement('div');
      textBox.className = 'text-box';
      textBox.style.left = x + 'px';
      textBox.style.top = y + 'px';
      textBox.style.width = '150px';
      textBox.style.height = '60px';
      textBox.style.fontSize = fontSize + 'px';
      
      const textContent = document.createElement('textarea');
      textContent.className = 'text-box-content';
      textContent.style.fontSize = fontSize + 'px';
      textContent.value = initialText;
      textContent.placeholder = 'è¾“å…¥æ–‡æœ¬...';
      
      textBox.appendChild(textContent);
      canvasContainer.appendChild(textBox);
      
      // æ·»åŠ è°ƒæ•´å¤§å°çš„å¥æŸ„
      const handle = document.createElement('div');
      handle.className = 'resize-handle resize-handle-se';
      textBox.appendChild(handle);
      
      // å®ç°æ‹–æ‹½å’Œè°ƒæ•´å¤§å°åŠŸèƒ½
      let isDragging = false;
      let isResizing = false;
      let offsetX, offsetY;
      let startX, startY;
      let startWidth, startHeight;
      
      textBox.addEventListener('mousedown', (e) => {
        if (e.target === handle) {
          isResizing = true;
          const rect = textBox.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startWidth = textBox.offsetWidth;
          startHeight = textBox.offsetHeight;
          e.preventDefault();
        } else if (e.target !== textContent) {
          isDragging = true;
          const rect = textBox.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;
          e.preventDefault();
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const containerRect = canvasContainer.getBoundingClientRect();
          let x = e.clientX - containerRect.left - offsetX;
          let y = e.clientY - containerRect.top - offsetY;
          
          // é™åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…
          x = Math.max(0, Math.min(x, canvasContainer.clientWidth - textBox.offsetWidth));
          y = Math.max(0, Math.min(y, canvasContainer.clientHeight - textBox.offsetHeight));
          
          textBox.style.left = x + 'px';
          textBox.style.top = y + 'px';
        } else if (isResizing) {
          const newWidth = startWidth + (e.clientX - startX);
          const newHeight = startHeight + (e.clientY - startY);
          
          if (newWidth > 50 && newHeight > 30) {
            textBox.style.width = newWidth + 'px';
            textBox.style.height = newHeight + 'px';
          }
        }
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
        isResizing = false;
      });
      
      // å¤„ç†å¤±å»ç„¦ç‚¹æ—¶åˆ é™¤ç©ºæ–‡æœ¬æ¡†
      textContent.addEventListener('blur', () => {
        if (textContent.value.trim() === '') {
          textBox.remove();
          // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
          saveStateToHistory();
        }
      });
    }

    // åˆå§‹åŒ–æ—¶ä¿å­˜åˆå§‹çŠ¶æ€
    saveStateToHistory();

    // Initialize cursor
    updateCursor();
  </script>
</body>
</html>